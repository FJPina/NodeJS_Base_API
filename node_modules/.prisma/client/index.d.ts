
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Direccion
 * 
 */
export type Direccion = $Result.DefaultSelection<Prisma.$DireccionPayload>
/**
 * Model Ganador
 * 
 */
export type Ganador = $Result.DefaultSelection<Prisma.$GanadorPayload>
/**
 * Model Login
 * 
 */
export type Login = $Result.DefaultSelection<Prisma.$LoginPayload>
/**
 * Model Modulo
 * 
 */
export type Modulo = $Result.DefaultSelection<Prisma.$ModuloPayload>
/**
 * Model Premio
 * 
 */
export type Premio = $Result.DefaultSelection<Prisma.$PremioPayload>
/**
 * Model Sesion
 * The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
 */
export type Sesion = $Result.DefaultSelection<Prisma.$SesionPayload>
/**
 * Model Sorteo
 * 
 */
export type Sorteo = $Result.DefaultSelection<Prisma.$SorteoPayload>
/**
 * Model TipoLogin
 * 
 */
export type TipoLogin = $Result.DefaultSelection<Prisma.$TipoLoginPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Direccions
 * const direccions = await prisma.direccion.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Direccions
   * const direccions = await prisma.direccion.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.direccion`: Exposes CRUD operations for the **Direccion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Direccions
    * const direccions = await prisma.direccion.findMany()
    * ```
    */
  get direccion(): Prisma.DireccionDelegate<ExtArgs>;

  /**
   * `prisma.ganador`: Exposes CRUD operations for the **Ganador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ganadors
    * const ganadors = await prisma.ganador.findMany()
    * ```
    */
  get ganador(): Prisma.GanadorDelegate<ExtArgs>;

  /**
   * `prisma.login`: Exposes CRUD operations for the **Login** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logins
    * const logins = await prisma.login.findMany()
    * ```
    */
  get login(): Prisma.LoginDelegate<ExtArgs>;

  /**
   * `prisma.modulo`: Exposes CRUD operations for the **Modulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modulos
    * const modulos = await prisma.modulo.findMany()
    * ```
    */
  get modulo(): Prisma.ModuloDelegate<ExtArgs>;

  /**
   * `prisma.premio`: Exposes CRUD operations for the **Premio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Premios
    * const premios = await prisma.premio.findMany()
    * ```
    */
  get premio(): Prisma.PremioDelegate<ExtArgs>;

  /**
   * `prisma.sesion`: Exposes CRUD operations for the **Sesion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sesions
    * const sesions = await prisma.sesion.findMany()
    * ```
    */
  get sesion(): Prisma.SesionDelegate<ExtArgs>;

  /**
   * `prisma.sorteo`: Exposes CRUD operations for the **Sorteo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sorteos
    * const sorteos = await prisma.sorteo.findMany()
    * ```
    */
  get sorteo(): Prisma.SorteoDelegate<ExtArgs>;

  /**
   * `prisma.tipoLogin`: Exposes CRUD operations for the **TipoLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoLogins
    * const tipoLogins = await prisma.tipoLogin.findMany()
    * ```
    */
  get tipoLogin(): Prisma.TipoLoginDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Direccion: 'Direccion',
    Ganador: 'Ganador',
    Login: 'Login',
    Modulo: 'Modulo',
    Premio: 'Premio',
    Sesion: 'Sesion',
    Sorteo: 'Sorteo',
    TipoLogin: 'TipoLogin',
    Usuario: 'Usuario'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'direccion' | 'ganador' | 'login' | 'modulo' | 'premio' | 'sesion' | 'sorteo' | 'tipoLogin' | 'usuario'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Direccion: {
        payload: Prisma.$DireccionPayload<ExtArgs>
        fields: Prisma.DireccionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DireccionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DireccionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>
          }
          findFirst: {
            args: Prisma.DireccionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DireccionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>
          }
          findMany: {
            args: Prisma.DireccionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>[]
          }
          create: {
            args: Prisma.DireccionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>
          }
          createMany: {
            args: Prisma.DireccionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DireccionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>
          }
          update: {
            args: Prisma.DireccionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>
          }
          deleteMany: {
            args: Prisma.DireccionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DireccionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DireccionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DireccionPayload>
          }
          aggregate: {
            args: Prisma.DireccionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDireccion>
          }
          groupBy: {
            args: Prisma.DireccionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DireccionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DireccionCountArgs<ExtArgs>,
            result: $Utils.Optional<DireccionCountAggregateOutputType> | number
          }
        }
      }
      Ganador: {
        payload: Prisma.$GanadorPayload<ExtArgs>
        fields: Prisma.GanadorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GanadorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GanadorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>
          }
          findFirst: {
            args: Prisma.GanadorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GanadorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>
          }
          findMany: {
            args: Prisma.GanadorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>[]
          }
          create: {
            args: Prisma.GanadorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>
          }
          createMany: {
            args: Prisma.GanadorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GanadorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>
          }
          update: {
            args: Prisma.GanadorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>
          }
          deleteMany: {
            args: Prisma.GanadorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GanadorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GanadorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GanadorPayload>
          }
          aggregate: {
            args: Prisma.GanadorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGanador>
          }
          groupBy: {
            args: Prisma.GanadorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GanadorGroupByOutputType>[]
          }
          count: {
            args: Prisma.GanadorCountArgs<ExtArgs>,
            result: $Utils.Optional<GanadorCountAggregateOutputType> | number
          }
        }
      }
      Login: {
        payload: Prisma.$LoginPayload<ExtArgs>
        fields: Prisma.LoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          findFirst: {
            args: Prisma.LoginFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          findMany: {
            args: Prisma.LoginFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>[]
          }
          create: {
            args: Prisma.LoginCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          createMany: {
            args: Prisma.LoginCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LoginDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          update: {
            args: Prisma.LoginUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          deleteMany: {
            args: Prisma.LoginDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LoginUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LoginUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LoginPayload>
          }
          aggregate: {
            args: Prisma.LoginAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLogin>
          }
          groupBy: {
            args: Prisma.LoginGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginCountArgs<ExtArgs>,
            result: $Utils.Optional<LoginCountAggregateOutputType> | number
          }
        }
      }
      Modulo: {
        payload: Prisma.$ModuloPayload<ExtArgs>
        fields: Prisma.ModuloFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuloFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuloFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findFirst: {
            args: Prisma.ModuloFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuloFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          findMany: {
            args: Prisma.ModuloFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>[]
          }
          create: {
            args: Prisma.ModuloCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          createMany: {
            args: Prisma.ModuloCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModuloDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          update: {
            args: Prisma.ModuloUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          deleteMany: {
            args: Prisma.ModuloDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModuloUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModuloUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ModuloPayload>
          }
          aggregate: {
            args: Prisma.ModuloAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModulo>
          }
          groupBy: {
            args: Prisma.ModuloGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModuloGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuloCountArgs<ExtArgs>,
            result: $Utils.Optional<ModuloCountAggregateOutputType> | number
          }
        }
      }
      Premio: {
        payload: Prisma.$PremioPayload<ExtArgs>
        fields: Prisma.PremioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PremioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PremioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          findFirst: {
            args: Prisma.PremioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PremioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          findMany: {
            args: Prisma.PremioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>[]
          }
          create: {
            args: Prisma.PremioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          createMany: {
            args: Prisma.PremioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PremioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          update: {
            args: Prisma.PremioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          deleteMany: {
            args: Prisma.PremioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PremioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PremioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          aggregate: {
            args: Prisma.PremioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePremio>
          }
          groupBy: {
            args: Prisma.PremioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PremioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PremioCountArgs<ExtArgs>,
            result: $Utils.Optional<PremioCountAggregateOutputType> | number
          }
        }
      }
      Sesion: {
        payload: Prisma.$SesionPayload<ExtArgs>
        fields: Prisma.SesionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SesionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SesionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          findFirst: {
            args: Prisma.SesionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SesionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          findMany: {
            args: Prisma.SesionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>[]
          }
          create: {
            args: Prisma.SesionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          createMany: {
            args: Prisma.SesionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SesionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          update: {
            args: Prisma.SesionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          deleteMany: {
            args: Prisma.SesionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SesionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SesionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          aggregate: {
            args: Prisma.SesionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSesion>
          }
          groupBy: {
            args: Prisma.SesionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SesionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SesionCountArgs<ExtArgs>,
            result: $Utils.Optional<SesionCountAggregateOutputType> | number
          }
        }
      }
      Sorteo: {
        payload: Prisma.$SorteoPayload<ExtArgs>
        fields: Prisma.SorteoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SorteoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SorteoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>
          }
          findFirst: {
            args: Prisma.SorteoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SorteoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>
          }
          findMany: {
            args: Prisma.SorteoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>[]
          }
          create: {
            args: Prisma.SorteoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>
          }
          createMany: {
            args: Prisma.SorteoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SorteoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>
          }
          update: {
            args: Prisma.SorteoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>
          }
          deleteMany: {
            args: Prisma.SorteoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SorteoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SorteoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SorteoPayload>
          }
          aggregate: {
            args: Prisma.SorteoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSorteo>
          }
          groupBy: {
            args: Prisma.SorteoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SorteoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SorteoCountArgs<ExtArgs>,
            result: $Utils.Optional<SorteoCountAggregateOutputType> | number
          }
        }
      }
      TipoLogin: {
        payload: Prisma.$TipoLoginPayload<ExtArgs>
        fields: Prisma.TipoLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoLoginFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoLoginFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>
          }
          findFirst: {
            args: Prisma.TipoLoginFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoLoginFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>
          }
          findMany: {
            args: Prisma.TipoLoginFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>[]
          }
          create: {
            args: Prisma.TipoLoginCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>
          }
          createMany: {
            args: Prisma.TipoLoginCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TipoLoginDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>
          }
          update: {
            args: Prisma.TipoLoginUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>
          }
          deleteMany: {
            args: Prisma.TipoLoginDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TipoLoginUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TipoLoginUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TipoLoginPayload>
          }
          aggregate: {
            args: Prisma.TipoLoginAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTipoLogin>
          }
          groupBy: {
            args: Prisma.TipoLoginGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TipoLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoLoginCountArgs<ExtArgs>,
            result: $Utils.Optional<TipoLoginCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    Direccion: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Direccion?: boolean | UsuarioCountOutputTypeCountDireccionArgs
  }

  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDireccionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DireccionWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Direccion
   */

  export type AggregateDireccion = {
    _count: DireccionCountAggregateOutputType | null
    _avg: DireccionAvgAggregateOutputType | null
    _sum: DireccionSumAggregateOutputType | null
    _min: DireccionMinAggregateOutputType | null
    _max: DireccionMaxAggregateOutputType | null
  }

  export type DireccionAvgAggregateOutputType = {
    IdDireccion: number | null
    IdUsuario: number | null
    Estatus: number | null
  }

  export type DireccionSumAggregateOutputType = {
    IdDireccion: number | null
    IdUsuario: number | null
    Estatus: number | null
  }

  export type DireccionMinAggregateOutputType = {
    IdDireccion: number | null
    IdUsuario: number | null
    Calle: string | null
    NumeroExt: string | null
    NumeroInt: string | null
    Colonia: string | null
    Municipio: string | null
    Estado: string | null
    CP: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type DireccionMaxAggregateOutputType = {
    IdDireccion: number | null
    IdUsuario: number | null
    Calle: string | null
    NumeroExt: string | null
    NumeroInt: string | null
    Colonia: string | null
    Municipio: string | null
    Estado: string | null
    CP: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type DireccionCountAggregateOutputType = {
    IdDireccion: number
    IdUsuario: number
    Calle: number
    NumeroExt: number
    NumeroInt: number
    Colonia: number
    Municipio: number
    Estado: number
    CP: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type DireccionAvgAggregateInputType = {
    IdDireccion?: true
    IdUsuario?: true
    Estatus?: true
  }

  export type DireccionSumAggregateInputType = {
    IdDireccion?: true
    IdUsuario?: true
    Estatus?: true
  }

  export type DireccionMinAggregateInputType = {
    IdDireccion?: true
    IdUsuario?: true
    Calle?: true
    NumeroExt?: true
    NumeroInt?: true
    Colonia?: true
    Municipio?: true
    Estado?: true
    CP?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type DireccionMaxAggregateInputType = {
    IdDireccion?: true
    IdUsuario?: true
    Calle?: true
    NumeroExt?: true
    NumeroInt?: true
    Colonia?: true
    Municipio?: true
    Estado?: true
    CP?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type DireccionCountAggregateInputType = {
    IdDireccion?: true
    IdUsuario?: true
    Calle?: true
    NumeroExt?: true
    NumeroInt?: true
    Colonia?: true
    Municipio?: true
    Estado?: true
    CP?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type DireccionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Direccion to aggregate.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: DireccionOrderByWithRelationInput | DireccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Direccions
    **/
    _count?: true | DireccionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DireccionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DireccionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DireccionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DireccionMaxAggregateInputType
  }

  export type GetDireccionAggregateType<T extends DireccionAggregateArgs> = {
        [P in keyof T & keyof AggregateDireccion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDireccion[P]>
      : GetScalarType<T[P], AggregateDireccion[P]>
  }




  export type DireccionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DireccionWhereInput
    orderBy?: DireccionOrderByWithAggregationInput | DireccionOrderByWithAggregationInput[]
    by: DireccionScalarFieldEnum[] | DireccionScalarFieldEnum
    having?: DireccionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DireccionCountAggregateInputType | true
    _avg?: DireccionAvgAggregateInputType
    _sum?: DireccionSumAggregateInputType
    _min?: DireccionMinAggregateInputType
    _max?: DireccionMaxAggregateInputType
  }

  export type DireccionGroupByOutputType = {
    IdDireccion: number
    IdUsuario: number
    Calle: string
    NumeroExt: string
    NumeroInt: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: DireccionCountAggregateOutputType | null
    _avg: DireccionAvgAggregateOutputType | null
    _sum: DireccionSumAggregateOutputType | null
    _min: DireccionMinAggregateOutputType | null
    _max: DireccionMaxAggregateOutputType | null
  }

  type GetDireccionGroupByPayload<T extends DireccionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DireccionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DireccionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DireccionGroupByOutputType[P]>
            : GetScalarType<T[P], DireccionGroupByOutputType[P]>
        }
      >
    >


  export type DireccionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdDireccion?: boolean
    IdUsuario?: boolean
    Calle?: boolean
    NumeroExt?: boolean
    NumeroInt?: boolean
    Colonia?: boolean
    Municipio?: boolean
    Estado?: boolean
    CP?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["direccion"]>

  export type DireccionSelectScalar = {
    IdDireccion?: boolean
    IdUsuario?: boolean
    Calle?: boolean
    NumeroExt?: boolean
    NumeroInt?: boolean
    Colonia?: boolean
    Municipio?: boolean
    Estado?: boolean
    CP?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }

  export type DireccionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $DireccionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Direccion"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdDireccion: number
      IdUsuario: number
      Calle: string
      NumeroExt: string
      NumeroInt: string | null
      Colonia: string
      Municipio: string
      Estado: string
      CP: string
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["direccion"]>
    composites: {}
  }


  type DireccionGetPayload<S extends boolean | null | undefined | DireccionDefaultArgs> = $Result.GetResult<Prisma.$DireccionPayload, S>

  type DireccionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DireccionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DireccionCountAggregateInputType | true
    }

  export interface DireccionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Direccion'], meta: { name: 'Direccion' } }
    /**
     * Find zero or one Direccion that matches the filter.
     * @param {DireccionFindUniqueArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DireccionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DireccionFindUniqueArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Direccion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DireccionFindUniqueOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DireccionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DireccionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Direccion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DireccionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DireccionFindFirstArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Direccion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindFirstOrThrowArgs} args - Arguments to find a Direccion
     * @example
     * // Get one Direccion
     * const direccion = await prisma.direccion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DireccionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DireccionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Direccions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Direccions
     * const direccions = await prisma.direccion.findMany()
     * 
     * // Get first 10 Direccions
     * const direccions = await prisma.direccion.findMany({ take: 10 })
     * 
     * // Only select the `IdDireccion`
     * const direccionWithIdDireccionOnly = await prisma.direccion.findMany({ select: { IdDireccion: true } })
     * 
    **/
    findMany<T extends DireccionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DireccionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Direccion.
     * @param {DireccionCreateArgs} args - Arguments to create a Direccion.
     * @example
     * // Create one Direccion
     * const Direccion = await prisma.direccion.create({
     *   data: {
     *     // ... data to create a Direccion
     *   }
     * })
     * 
    **/
    create<T extends DireccionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DireccionCreateArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Direccions.
     *     @param {DireccionCreateManyArgs} args - Arguments to create many Direccions.
     *     @example
     *     // Create many Direccions
     *     const direccion = await prisma.direccion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DireccionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DireccionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Direccion.
     * @param {DireccionDeleteArgs} args - Arguments to delete one Direccion.
     * @example
     * // Delete one Direccion
     * const Direccion = await prisma.direccion.delete({
     *   where: {
     *     // ... filter to delete one Direccion
     *   }
     * })
     * 
    **/
    delete<T extends DireccionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DireccionDeleteArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Direccion.
     * @param {DireccionUpdateArgs} args - Arguments to update one Direccion.
     * @example
     * // Update one Direccion
     * const direccion = await prisma.direccion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DireccionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DireccionUpdateArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Direccions.
     * @param {DireccionDeleteManyArgs} args - Arguments to filter Direccions to delete.
     * @example
     * // Delete a few Direccions
     * const { count } = await prisma.direccion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DireccionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DireccionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Direccions
     * const direccion = await prisma.direccion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DireccionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DireccionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Direccion.
     * @param {DireccionUpsertArgs} args - Arguments to update or create a Direccion.
     * @example
     * // Update or create a Direccion
     * const direccion = await prisma.direccion.upsert({
     *   create: {
     *     // ... data to create a Direccion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Direccion we want to update
     *   }
     * })
    **/
    upsert<T extends DireccionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DireccionUpsertArgs<ExtArgs>>
    ): Prisma__DireccionClient<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Direccions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionCountArgs} args - Arguments to filter Direccions to count.
     * @example
     * // Count the number of Direccions
     * const count = await prisma.direccion.count({
     *   where: {
     *     // ... the filter for the Direccions we want to count
     *   }
     * })
    **/
    count<T extends DireccionCountArgs>(
      args?: Subset<T, DireccionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DireccionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DireccionAggregateArgs>(args: Subset<T, DireccionAggregateArgs>): Prisma.PrismaPromise<GetDireccionAggregateType<T>>

    /**
     * Group by Direccion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DireccionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DireccionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DireccionGroupByArgs['orderBy'] }
        : { orderBy?: DireccionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DireccionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDireccionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Direccion model
   */
  readonly fields: DireccionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Direccion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DireccionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Direccion model
   */ 
  interface DireccionFieldRefs {
    readonly IdDireccion: FieldRef<"Direccion", 'Int'>
    readonly IdUsuario: FieldRef<"Direccion", 'Int'>
    readonly Calle: FieldRef<"Direccion", 'String'>
    readonly NumeroExt: FieldRef<"Direccion", 'String'>
    readonly NumeroInt: FieldRef<"Direccion", 'String'>
    readonly Colonia: FieldRef<"Direccion", 'String'>
    readonly Municipio: FieldRef<"Direccion", 'String'>
    readonly Estado: FieldRef<"Direccion", 'String'>
    readonly CP: FieldRef<"Direccion", 'String'>
    readonly FechaCreacion: FieldRef<"Direccion", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Direccion", 'DateTime'>
    readonly Estatus: FieldRef<"Direccion", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Direccion findUnique
   */
  export type DireccionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * Filter, which Direccion to fetch.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion findUniqueOrThrow
   */
  export type DireccionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * Filter, which Direccion to fetch.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion findFirst
   */
  export type DireccionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * Filter, which Direccion to fetch.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: DireccionOrderByWithRelationInput | DireccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Direccions.
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Direccions.
     */
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[]
  }


  /**
   * Direccion findFirstOrThrow
   */
  export type DireccionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * Filter, which Direccion to fetch.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: DireccionOrderByWithRelationInput | DireccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Direccions.
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Direccions.
     */
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[]
  }


  /**
   * Direccion findMany
   */
  export type DireccionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * Filter, which Direccions to fetch.
     */
    where?: DireccionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Direccions to fetch.
     */
    orderBy?: DireccionOrderByWithRelationInput | DireccionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Direccions.
     */
    cursor?: DireccionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Direccions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Direccions.
     */
    skip?: number
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[]
  }


  /**
   * Direccion create
   */
  export type DireccionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * The data needed to create a Direccion.
     */
    data: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>
  }


  /**
   * Direccion createMany
   */
  export type DireccionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Direccions.
     */
    data: DireccionCreateManyInput | DireccionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Direccion update
   */
  export type DireccionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * The data needed to update a Direccion.
     */
    data: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>
    /**
     * Choose, which Direccion to update.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion updateMany
   */
  export type DireccionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Direccions.
     */
    data: XOR<DireccionUpdateManyMutationInput, DireccionUncheckedUpdateManyInput>
    /**
     * Filter which Direccions to update
     */
    where?: DireccionWhereInput
  }


  /**
   * Direccion upsert
   */
  export type DireccionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * The filter to search for the Direccion to update in case it exists.
     */
    where: DireccionWhereUniqueInput
    /**
     * In case the Direccion found by the `where` argument doesn't exist, create a new Direccion with this data.
     */
    create: XOR<DireccionCreateInput, DireccionUncheckedCreateInput>
    /**
     * In case the Direccion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DireccionUpdateInput, DireccionUncheckedUpdateInput>
  }


  /**
   * Direccion delete
   */
  export type DireccionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    /**
     * Filter which Direccion to delete.
     */
    where: DireccionWhereUniqueInput
  }


  /**
   * Direccion deleteMany
   */
  export type DireccionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Direccions to delete
     */
    where?: DireccionWhereInput
  }


  /**
   * Direccion without action
   */
  export type DireccionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
  }



  /**
   * Model Ganador
   */

  export type AggregateGanador = {
    _count: GanadorCountAggregateOutputType | null
    _avg: GanadorAvgAggregateOutputType | null
    _sum: GanadorSumAggregateOutputType | null
    _min: GanadorMinAggregateOutputType | null
    _max: GanadorMaxAggregateOutputType | null
  }

  export type GanadorAvgAggregateOutputType = {
    IdGanador: number | null
    IdSorteo: number | null
    Lugar: number | null
    Estatus: number | null
  }

  export type GanadorSumAggregateOutputType = {
    IdGanador: number | null
    IdSorteo: number | null
    Lugar: number | null
    Estatus: number | null
  }

  export type GanadorMinAggregateOutputType = {
    IdGanador: number | null
    IdSorteo: number | null
    Lugar: number | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type GanadorMaxAggregateOutputType = {
    IdGanador: number | null
    IdSorteo: number | null
    Lugar: number | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type GanadorCountAggregateOutputType = {
    IdGanador: number
    IdSorteo: number
    Lugar: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type GanadorAvgAggregateInputType = {
    IdGanador?: true
    IdSorteo?: true
    Lugar?: true
    Estatus?: true
  }

  export type GanadorSumAggregateInputType = {
    IdGanador?: true
    IdSorteo?: true
    Lugar?: true
    Estatus?: true
  }

  export type GanadorMinAggregateInputType = {
    IdGanador?: true
    IdSorteo?: true
    Lugar?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type GanadorMaxAggregateInputType = {
    IdGanador?: true
    IdSorteo?: true
    Lugar?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type GanadorCountAggregateInputType = {
    IdGanador?: true
    IdSorteo?: true
    Lugar?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type GanadorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ganador to aggregate.
     */
    where?: GanadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ganadors to fetch.
     */
    orderBy?: GanadorOrderByWithRelationInput | GanadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GanadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ganadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ganadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ganadors
    **/
    _count?: true | GanadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GanadorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GanadorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GanadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GanadorMaxAggregateInputType
  }

  export type GetGanadorAggregateType<T extends GanadorAggregateArgs> = {
        [P in keyof T & keyof AggregateGanador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGanador[P]>
      : GetScalarType<T[P], AggregateGanador[P]>
  }




  export type GanadorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GanadorWhereInput
    orderBy?: GanadorOrderByWithAggregationInput | GanadorOrderByWithAggregationInput[]
    by: GanadorScalarFieldEnum[] | GanadorScalarFieldEnum
    having?: GanadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GanadorCountAggregateInputType | true
    _avg?: GanadorAvgAggregateInputType
    _sum?: GanadorSumAggregateInputType
    _min?: GanadorMinAggregateInputType
    _max?: GanadorMaxAggregateInputType
  }

  export type GanadorGroupByOutputType = {
    IdGanador: number
    IdSorteo: number
    Lugar: number
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: GanadorCountAggregateOutputType | null
    _avg: GanadorAvgAggregateOutputType | null
    _sum: GanadorSumAggregateOutputType | null
    _min: GanadorMinAggregateOutputType | null
    _max: GanadorMaxAggregateOutputType | null
  }

  type GetGanadorGroupByPayload<T extends GanadorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GanadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GanadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GanadorGroupByOutputType[P]>
            : GetScalarType<T[P], GanadorGroupByOutputType[P]>
        }
      >
    >


  export type GanadorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdGanador?: boolean
    IdSorteo?: boolean
    Lugar?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }, ExtArgs["result"]["ganador"]>

  export type GanadorSelectScalar = {
    IdGanador?: boolean
    IdSorteo?: boolean
    Lugar?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }


  export type $GanadorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ganador"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdGanador: number
      IdSorteo: number
      Lugar: number
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["ganador"]>
    composites: {}
  }


  type GanadorGetPayload<S extends boolean | null | undefined | GanadorDefaultArgs> = $Result.GetResult<Prisma.$GanadorPayload, S>

  type GanadorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GanadorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GanadorCountAggregateInputType | true
    }

  export interface GanadorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ganador'], meta: { name: 'Ganador' } }
    /**
     * Find zero or one Ganador that matches the filter.
     * @param {GanadorFindUniqueArgs} args - Arguments to find a Ganador
     * @example
     * // Get one Ganador
     * const ganador = await prisma.ganador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GanadorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GanadorFindUniqueArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ganador that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GanadorFindUniqueOrThrowArgs} args - Arguments to find a Ganador
     * @example
     * // Get one Ganador
     * const ganador = await prisma.ganador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GanadorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GanadorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ganador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorFindFirstArgs} args - Arguments to find a Ganador
     * @example
     * // Get one Ganador
     * const ganador = await prisma.ganador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GanadorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GanadorFindFirstArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ganador that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorFindFirstOrThrowArgs} args - Arguments to find a Ganador
     * @example
     * // Get one Ganador
     * const ganador = await prisma.ganador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GanadorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GanadorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ganadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ganadors
     * const ganadors = await prisma.ganador.findMany()
     * 
     * // Get first 10 Ganadors
     * const ganadors = await prisma.ganador.findMany({ take: 10 })
     * 
     * // Only select the `IdGanador`
     * const ganadorWithIdGanadorOnly = await prisma.ganador.findMany({ select: { IdGanador: true } })
     * 
    **/
    findMany<T extends GanadorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GanadorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ganador.
     * @param {GanadorCreateArgs} args - Arguments to create a Ganador.
     * @example
     * // Create one Ganador
     * const Ganador = await prisma.ganador.create({
     *   data: {
     *     // ... data to create a Ganador
     *   }
     * })
     * 
    **/
    create<T extends GanadorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GanadorCreateArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ganadors.
     *     @param {GanadorCreateManyArgs} args - Arguments to create many Ganadors.
     *     @example
     *     // Create many Ganadors
     *     const ganador = await prisma.ganador.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GanadorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GanadorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ganador.
     * @param {GanadorDeleteArgs} args - Arguments to delete one Ganador.
     * @example
     * // Delete one Ganador
     * const Ganador = await prisma.ganador.delete({
     *   where: {
     *     // ... filter to delete one Ganador
     *   }
     * })
     * 
    **/
    delete<T extends GanadorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GanadorDeleteArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ganador.
     * @param {GanadorUpdateArgs} args - Arguments to update one Ganador.
     * @example
     * // Update one Ganador
     * const ganador = await prisma.ganador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GanadorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GanadorUpdateArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ganadors.
     * @param {GanadorDeleteManyArgs} args - Arguments to filter Ganadors to delete.
     * @example
     * // Delete a few Ganadors
     * const { count } = await prisma.ganador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GanadorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GanadorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ganadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ganadors
     * const ganador = await prisma.ganador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GanadorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GanadorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ganador.
     * @param {GanadorUpsertArgs} args - Arguments to update or create a Ganador.
     * @example
     * // Update or create a Ganador
     * const ganador = await prisma.ganador.upsert({
     *   create: {
     *     // ... data to create a Ganador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ganador we want to update
     *   }
     * })
    **/
    upsert<T extends GanadorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GanadorUpsertArgs<ExtArgs>>
    ): Prisma__GanadorClient<$Result.GetResult<Prisma.$GanadorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ganadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorCountArgs} args - Arguments to filter Ganadors to count.
     * @example
     * // Count the number of Ganadors
     * const count = await prisma.ganador.count({
     *   where: {
     *     // ... the filter for the Ganadors we want to count
     *   }
     * })
    **/
    count<T extends GanadorCountArgs>(
      args?: Subset<T, GanadorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GanadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ganador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GanadorAggregateArgs>(args: Subset<T, GanadorAggregateArgs>): Prisma.PrismaPromise<GetGanadorAggregateType<T>>

    /**
     * Group by Ganador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GanadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GanadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GanadorGroupByArgs['orderBy'] }
        : { orderBy?: GanadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GanadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGanadorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ganador model
   */
  readonly fields: GanadorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ganador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GanadorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ganador model
   */ 
  interface GanadorFieldRefs {
    readonly IdGanador: FieldRef<"Ganador", 'Int'>
    readonly IdSorteo: FieldRef<"Ganador", 'Int'>
    readonly Lugar: FieldRef<"Ganador", 'Int'>
    readonly FechaCreacion: FieldRef<"Ganador", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Ganador", 'DateTime'>
    readonly Estatus: FieldRef<"Ganador", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Ganador findUnique
   */
  export type GanadorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * Filter, which Ganador to fetch.
     */
    where: GanadorWhereUniqueInput
  }


  /**
   * Ganador findUniqueOrThrow
   */
  export type GanadorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * Filter, which Ganador to fetch.
     */
    where: GanadorWhereUniqueInput
  }


  /**
   * Ganador findFirst
   */
  export type GanadorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * Filter, which Ganador to fetch.
     */
    where?: GanadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ganadors to fetch.
     */
    orderBy?: GanadorOrderByWithRelationInput | GanadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ganadors.
     */
    cursor?: GanadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ganadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ganadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ganadors.
     */
    distinct?: GanadorScalarFieldEnum | GanadorScalarFieldEnum[]
  }


  /**
   * Ganador findFirstOrThrow
   */
  export type GanadorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * Filter, which Ganador to fetch.
     */
    where?: GanadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ganadors to fetch.
     */
    orderBy?: GanadorOrderByWithRelationInput | GanadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ganadors.
     */
    cursor?: GanadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ganadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ganadors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ganadors.
     */
    distinct?: GanadorScalarFieldEnum | GanadorScalarFieldEnum[]
  }


  /**
   * Ganador findMany
   */
  export type GanadorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * Filter, which Ganadors to fetch.
     */
    where?: GanadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ganadors to fetch.
     */
    orderBy?: GanadorOrderByWithRelationInput | GanadorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ganadors.
     */
    cursor?: GanadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ganadors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ganadors.
     */
    skip?: number
    distinct?: GanadorScalarFieldEnum | GanadorScalarFieldEnum[]
  }


  /**
   * Ganador create
   */
  export type GanadorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * The data needed to create a Ganador.
     */
    data: XOR<GanadorCreateInput, GanadorUncheckedCreateInput>
  }


  /**
   * Ganador createMany
   */
  export type GanadorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ganadors.
     */
    data: GanadorCreateManyInput | GanadorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ganador update
   */
  export type GanadorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * The data needed to update a Ganador.
     */
    data: XOR<GanadorUpdateInput, GanadorUncheckedUpdateInput>
    /**
     * Choose, which Ganador to update.
     */
    where: GanadorWhereUniqueInput
  }


  /**
   * Ganador updateMany
   */
  export type GanadorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ganadors.
     */
    data: XOR<GanadorUpdateManyMutationInput, GanadorUncheckedUpdateManyInput>
    /**
     * Filter which Ganadors to update
     */
    where?: GanadorWhereInput
  }


  /**
   * Ganador upsert
   */
  export type GanadorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * The filter to search for the Ganador to update in case it exists.
     */
    where: GanadorWhereUniqueInput
    /**
     * In case the Ganador found by the `where` argument doesn't exist, create a new Ganador with this data.
     */
    create: XOR<GanadorCreateInput, GanadorUncheckedCreateInput>
    /**
     * In case the Ganador was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GanadorUpdateInput, GanadorUncheckedUpdateInput>
  }


  /**
   * Ganador delete
   */
  export type GanadorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
    /**
     * Filter which Ganador to delete.
     */
    where: GanadorWhereUniqueInput
  }


  /**
   * Ganador deleteMany
   */
  export type GanadorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ganadors to delete
     */
    where?: GanadorWhereInput
  }


  /**
   * Ganador without action
   */
  export type GanadorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ganador
     */
    select?: GanadorSelect<ExtArgs> | null
  }



  /**
   * Model Login
   */

  export type AggregateLogin = {
    _count: LoginCountAggregateOutputType | null
    _avg: LoginAvgAggregateOutputType | null
    _sum: LoginSumAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  export type LoginAvgAggregateOutputType = {
    IdLogin: number | null
    IdUsuario: number | null
    IdTipoLogin: number | null
    Estatus: number | null
  }

  export type LoginSumAggregateOutputType = {
    IdLogin: number | null
    IdUsuario: number | null
    IdTipoLogin: number | null
    Estatus: number | null
  }

  export type LoginMinAggregateOutputType = {
    IdLogin: number | null
    IdUsuario: number | null
    Correo: string | null
    Contrasena: string | null
    IdTipoLogin: number | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type LoginMaxAggregateOutputType = {
    IdLogin: number | null
    IdUsuario: number | null
    Correo: string | null
    Contrasena: string | null
    IdTipoLogin: number | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type LoginCountAggregateOutputType = {
    IdLogin: number
    IdUsuario: number
    Correo: number
    Contrasena: number
    IdTipoLogin: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type LoginAvgAggregateInputType = {
    IdLogin?: true
    IdUsuario?: true
    IdTipoLogin?: true
    Estatus?: true
  }

  export type LoginSumAggregateInputType = {
    IdLogin?: true
    IdUsuario?: true
    IdTipoLogin?: true
    Estatus?: true
  }

  export type LoginMinAggregateInputType = {
    IdLogin?: true
    IdUsuario?: true
    Correo?: true
    Contrasena?: true
    IdTipoLogin?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type LoginMaxAggregateInputType = {
    IdLogin?: true
    IdUsuario?: true
    Correo?: true
    Contrasena?: true
    IdTipoLogin?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type LoginCountAggregateInputType = {
    IdLogin?: true
    IdUsuario?: true
    Correo?: true
    Contrasena?: true
    IdTipoLogin?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type LoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Login to aggregate.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logins
    **/
    _count?: true | LoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginMaxAggregateInputType
  }

  export type GetLoginAggregateType<T extends LoginAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin[P]>
      : GetScalarType<T[P], AggregateLogin[P]>
  }




  export type LoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginWhereInput
    orderBy?: LoginOrderByWithAggregationInput | LoginOrderByWithAggregationInput[]
    by: LoginScalarFieldEnum[] | LoginScalarFieldEnum
    having?: LoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginCountAggregateInputType | true
    _avg?: LoginAvgAggregateInputType
    _sum?: LoginSumAggregateInputType
    _min?: LoginMinAggregateInputType
    _max?: LoginMaxAggregateInputType
  }

  export type LoginGroupByOutputType = {
    IdLogin: number
    IdUsuario: number
    Correo: string
    Contrasena: string
    IdTipoLogin: number
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: LoginCountAggregateOutputType | null
    _avg: LoginAvgAggregateOutputType | null
    _sum: LoginSumAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  type GetLoginGroupByPayload<T extends LoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginGroupByOutputType[P]>
            : GetScalarType<T[P], LoginGroupByOutputType[P]>
        }
      >
    >


  export type LoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdLogin?: boolean
    IdUsuario?: boolean
    Correo?: boolean
    Contrasena?: boolean
    IdTipoLogin?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["login"]>

  export type LoginSelectScalar = {
    IdLogin?: boolean
    IdUsuario?: boolean
    Correo?: boolean
    Contrasena?: boolean
    IdTipoLogin?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }

  export type LoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }


  export type $LoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Login"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IdLogin: number
      IdUsuario: number
      Correo: string
      Contrasena: string
      IdTipoLogin: number
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["login"]>
    composites: {}
  }


  type LoginGetPayload<S extends boolean | null | undefined | LoginDefaultArgs> = $Result.GetResult<Prisma.$LoginPayload, S>

  type LoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoginCountAggregateInputType | true
    }

  export interface LoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Login'], meta: { name: 'Login' } }
    /**
     * Find zero or one Login that matches the filter.
     * @param {LoginFindUniqueArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LoginFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LoginFindUniqueArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Login that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LoginFindUniqueOrThrowArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LoginFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoginFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Login that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindFirstArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LoginFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LoginFindFirstArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Login that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindFirstOrThrowArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LoginFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LoginFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logins
     * const logins = await prisma.login.findMany()
     * 
     * // Get first 10 Logins
     * const logins = await prisma.login.findMany({ take: 10 })
     * 
     * // Only select the `IdLogin`
     * const loginWithIdLoginOnly = await prisma.login.findMany({ select: { IdLogin: true } })
     * 
    **/
    findMany<T extends LoginFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoginFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Login.
     * @param {LoginCreateArgs} args - Arguments to create a Login.
     * @example
     * // Create one Login
     * const Login = await prisma.login.create({
     *   data: {
     *     // ... data to create a Login
     *   }
     * })
     * 
    **/
    create<T extends LoginCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LoginCreateArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Logins.
     *     @param {LoginCreateManyArgs} args - Arguments to create many Logins.
     *     @example
     *     // Create many Logins
     *     const login = await prisma.login.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LoginCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoginCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Login.
     * @param {LoginDeleteArgs} args - Arguments to delete one Login.
     * @example
     * // Delete one Login
     * const Login = await prisma.login.delete({
     *   where: {
     *     // ... filter to delete one Login
     *   }
     * })
     * 
    **/
    delete<T extends LoginDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LoginDeleteArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Login.
     * @param {LoginUpdateArgs} args - Arguments to update one Login.
     * @example
     * // Update one Login
     * const login = await prisma.login.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LoginUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LoginUpdateArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Logins.
     * @param {LoginDeleteManyArgs} args - Arguments to filter Logins to delete.
     * @example
     * // Delete a few Logins
     * const { count } = await prisma.login.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LoginDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LoginDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logins
     * const login = await prisma.login.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LoginUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LoginUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login.
     * @param {LoginUpsertArgs} args - Arguments to update or create a Login.
     * @example
     * // Update or create a Login
     * const login = await prisma.login.upsert({
     *   create: {
     *     // ... data to create a Login
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login we want to update
     *   }
     * })
    **/
    upsert<T extends LoginUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LoginUpsertArgs<ExtArgs>>
    ): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCountArgs} args - Arguments to filter Logins to count.
     * @example
     * // Count the number of Logins
     * const count = await prisma.login.count({
     *   where: {
     *     // ... the filter for the Logins we want to count
     *   }
     * })
    **/
    count<T extends LoginCountArgs>(
      args?: Subset<T, LoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAggregateArgs>(args: Subset<T, LoginAggregateArgs>): Prisma.PrismaPromise<GetLoginAggregateType<T>>

    /**
     * Group by Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginGroupByArgs['orderBy'] }
        : { orderBy?: LoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Login model
   */
  readonly fields: LoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Login.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Login model
   */ 
  interface LoginFieldRefs {
    readonly IdLogin: FieldRef<"Login", 'Int'>
    readonly IdUsuario: FieldRef<"Login", 'Int'>
    readonly Correo: FieldRef<"Login", 'String'>
    readonly Contrasena: FieldRef<"Login", 'String'>
    readonly IdTipoLogin: FieldRef<"Login", 'Int'>
    readonly FechaCreacion: FieldRef<"Login", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Login", 'DateTime'>
    readonly Estatus: FieldRef<"Login", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Login findUnique
   */
  export type LoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where: LoginWhereUniqueInput
  }


  /**
   * Login findUniqueOrThrow
   */
  export type LoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where: LoginWhereUniqueInput
  }


  /**
   * Login findFirst
   */
  export type LoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logins.
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logins.
     */
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }


  /**
   * Login findFirstOrThrow
   */
  export type LoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Login to fetch.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logins.
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logins.
     */
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }


  /**
   * Login findMany
   */
  export type LoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter, which Logins to fetch.
     */
    where?: LoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logins to fetch.
     */
    orderBy?: LoginOrderByWithRelationInput | LoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logins.
     */
    cursor?: LoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logins.
     */
    skip?: number
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }


  /**
   * Login create
   */
  export type LoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * The data needed to create a Login.
     */
    data: XOR<LoginCreateInput, LoginUncheckedCreateInput>
  }


  /**
   * Login createMany
   */
  export type LoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logins.
     */
    data: LoginCreateManyInput | LoginCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Login update
   */
  export type LoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * The data needed to update a Login.
     */
    data: XOR<LoginUpdateInput, LoginUncheckedUpdateInput>
    /**
     * Choose, which Login to update.
     */
    where: LoginWhereUniqueInput
  }


  /**
   * Login updateMany
   */
  export type LoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logins.
     */
    data: XOR<LoginUpdateManyMutationInput, LoginUncheckedUpdateManyInput>
    /**
     * Filter which Logins to update
     */
    where?: LoginWhereInput
  }


  /**
   * Login upsert
   */
  export type LoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * The filter to search for the Login to update in case it exists.
     */
    where: LoginWhereUniqueInput
    /**
     * In case the Login found by the `where` argument doesn't exist, create a new Login with this data.
     */
    create: XOR<LoginCreateInput, LoginUncheckedCreateInput>
    /**
     * In case the Login was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginUpdateInput, LoginUncheckedUpdateInput>
  }


  /**
   * Login delete
   */
  export type LoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    /**
     * Filter which Login to delete.
     */
    where: LoginWhereUniqueInput
  }


  /**
   * Login deleteMany
   */
  export type LoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logins to delete
     */
    where?: LoginWhereInput
  }


  /**
   * Login without action
   */
  export type LoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
  }



  /**
   * Model Modulo
   */

  export type AggregateModulo = {
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  export type ModuloAvgAggregateOutputType = {
    IdModulo: number | null
    Estatus: number | null
  }

  export type ModuloSumAggregateOutputType = {
    IdModulo: number | null
    Estatus: number | null
  }

  export type ModuloMinAggregateOutputType = {
    IdModulo: number | null
    Descripcion: string | null
    Icono: string | null
    Ruta: string | null
    Padre: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type ModuloMaxAggregateOutputType = {
    IdModulo: number | null
    Descripcion: string | null
    Icono: string | null
    Ruta: string | null
    Padre: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type ModuloCountAggregateOutputType = {
    IdModulo: number
    Descripcion: number
    Icono: number
    Ruta: number
    Padre: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type ModuloAvgAggregateInputType = {
    IdModulo?: true
    Estatus?: true
  }

  export type ModuloSumAggregateInputType = {
    IdModulo?: true
    Estatus?: true
  }

  export type ModuloMinAggregateInputType = {
    IdModulo?: true
    Descripcion?: true
    Icono?: true
    Ruta?: true
    Padre?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type ModuloMaxAggregateInputType = {
    IdModulo?: true
    Descripcion?: true
    Icono?: true
    Ruta?: true
    Padre?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type ModuloCountAggregateInputType = {
    IdModulo?: true
    Descripcion?: true
    Icono?: true
    Ruta?: true
    Padre?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type ModuloAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulo to aggregate.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modulos
    **/
    _count?: true | ModuloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuloMaxAggregateInputType
  }

  export type GetModuloAggregateType<T extends ModuloAggregateArgs> = {
        [P in keyof T & keyof AggregateModulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulo[P]>
      : GetScalarType<T[P], AggregateModulo[P]>
  }




  export type ModuloGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuloWhereInput
    orderBy?: ModuloOrderByWithAggregationInput | ModuloOrderByWithAggregationInput[]
    by: ModuloScalarFieldEnum[] | ModuloScalarFieldEnum
    having?: ModuloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuloCountAggregateInputType | true
    _avg?: ModuloAvgAggregateInputType
    _sum?: ModuloSumAggregateInputType
    _min?: ModuloMinAggregateInputType
    _max?: ModuloMaxAggregateInputType
  }

  export type ModuloGroupByOutputType = {
    IdModulo: number
    Descripcion: string
    Icono: string
    Ruta: string
    Padre: string
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: ModuloCountAggregateOutputType | null
    _avg: ModuloAvgAggregateOutputType | null
    _sum: ModuloSumAggregateOutputType | null
    _min: ModuloMinAggregateOutputType | null
    _max: ModuloMaxAggregateOutputType | null
  }

  type GetModuloGroupByPayload<T extends ModuloGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuloGroupByOutputType[P]>
            : GetScalarType<T[P], ModuloGroupByOutputType[P]>
        }
      >
    >


  export type ModuloSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdModulo?: boolean
    Descripcion?: boolean
    Icono?: boolean
    Ruta?: boolean
    Padre?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }, ExtArgs["result"]["modulo"]>

  export type ModuloSelectScalar = {
    IdModulo?: boolean
    Descripcion?: boolean
    Icono?: boolean
    Ruta?: boolean
    Padre?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }


  export type $ModuloPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Modulo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdModulo: number
      Descripcion: string
      Icono: string
      Ruta: string
      Padre: string
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["modulo"]>
    composites: {}
  }


  type ModuloGetPayload<S extends boolean | null | undefined | ModuloDefaultArgs> = $Result.GetResult<Prisma.$ModuloPayload, S>

  type ModuloCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuloFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuloCountAggregateInputType | true
    }

  export interface ModuloDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Modulo'], meta: { name: 'Modulo' } }
    /**
     * Find zero or one Modulo that matches the filter.
     * @param {ModuloFindUniqueArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModuloFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModuloFindUniqueArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Modulo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModuloFindUniqueOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModuloFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuloFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Modulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModuloFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuloFindFirstArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Modulo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindFirstOrThrowArgs} args - Arguments to find a Modulo
     * @example
     * // Get one Modulo
     * const modulo = await prisma.modulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModuloFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuloFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Modulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modulos
     * const modulos = await prisma.modulo.findMany()
     * 
     * // Get first 10 Modulos
     * const modulos = await prisma.modulo.findMany({ take: 10 })
     * 
     * // Only select the `IdModulo`
     * const moduloWithIdModuloOnly = await prisma.modulo.findMany({ select: { IdModulo: true } })
     * 
    **/
    findMany<T extends ModuloFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuloFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Modulo.
     * @param {ModuloCreateArgs} args - Arguments to create a Modulo.
     * @example
     * // Create one Modulo
     * const Modulo = await prisma.modulo.create({
     *   data: {
     *     // ... data to create a Modulo
     *   }
     * })
     * 
    **/
    create<T extends ModuloCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModuloCreateArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Modulos.
     *     @param {ModuloCreateManyArgs} args - Arguments to create many Modulos.
     *     @example
     *     // Create many Modulos
     *     const modulo = await prisma.modulo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModuloCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuloCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Modulo.
     * @param {ModuloDeleteArgs} args - Arguments to delete one Modulo.
     * @example
     * // Delete one Modulo
     * const Modulo = await prisma.modulo.delete({
     *   where: {
     *     // ... filter to delete one Modulo
     *   }
     * })
     * 
    **/
    delete<T extends ModuloDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModuloDeleteArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Modulo.
     * @param {ModuloUpdateArgs} args - Arguments to update one Modulo.
     * @example
     * // Update one Modulo
     * const modulo = await prisma.modulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModuloUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModuloUpdateArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Modulos.
     * @param {ModuloDeleteManyArgs} args - Arguments to filter Modulos to delete.
     * @example
     * // Delete a few Modulos
     * const { count } = await prisma.modulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModuloDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuloDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modulos
     * const modulo = await prisma.modulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModuloUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModuloUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modulo.
     * @param {ModuloUpsertArgs} args - Arguments to update or create a Modulo.
     * @example
     * // Update or create a Modulo
     * const modulo = await prisma.modulo.upsert({
     *   create: {
     *     // ... data to create a Modulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modulo we want to update
     *   }
     * })
    **/
    upsert<T extends ModuloUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModuloUpsertArgs<ExtArgs>>
    ): Prisma__ModuloClient<$Result.GetResult<Prisma.$ModuloPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Modulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloCountArgs} args - Arguments to filter Modulos to count.
     * @example
     * // Count the number of Modulos
     * const count = await prisma.modulo.count({
     *   where: {
     *     // ... the filter for the Modulos we want to count
     *   }
     * })
    **/
    count<T extends ModuloCountArgs>(
      args?: Subset<T, ModuloCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuloAggregateArgs>(args: Subset<T, ModuloAggregateArgs>): Prisma.PrismaPromise<GetModuloAggregateType<T>>

    /**
     * Group by Modulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuloGroupByArgs['orderBy'] }
        : { orderBy?: ModuloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuloGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Modulo model
   */
  readonly fields: ModuloFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Modulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuloClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Modulo model
   */ 
  interface ModuloFieldRefs {
    readonly IdModulo: FieldRef<"Modulo", 'Int'>
    readonly Descripcion: FieldRef<"Modulo", 'String'>
    readonly Icono: FieldRef<"Modulo", 'String'>
    readonly Ruta: FieldRef<"Modulo", 'String'>
    readonly Padre: FieldRef<"Modulo", 'String'>
    readonly FechaCreacion: FieldRef<"Modulo", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Modulo", 'DateTime'>
    readonly Estatus: FieldRef<"Modulo", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Modulo findUnique
   */
  export type ModuloFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }


  /**
   * Modulo findUniqueOrThrow
   */
  export type ModuloFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where: ModuloWhereUniqueInput
  }


  /**
   * Modulo findFirst
   */
  export type ModuloFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }


  /**
   * Modulo findFirstOrThrow
   */
  export type ModuloFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulo to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modulos.
     */
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }


  /**
   * Modulo findMany
   */
  export type ModuloFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter, which Modulos to fetch.
     */
    where?: ModuloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modulos to fetch.
     */
    orderBy?: ModuloOrderByWithRelationInput | ModuloOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modulos.
     */
    cursor?: ModuloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modulos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modulos.
     */
    skip?: number
    distinct?: ModuloScalarFieldEnum | ModuloScalarFieldEnum[]
  }


  /**
   * Modulo create
   */
  export type ModuloCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * The data needed to create a Modulo.
     */
    data: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
  }


  /**
   * Modulo createMany
   */
  export type ModuloCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modulos.
     */
    data: ModuloCreateManyInput | ModuloCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Modulo update
   */
  export type ModuloUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * The data needed to update a Modulo.
     */
    data: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
    /**
     * Choose, which Modulo to update.
     */
    where: ModuloWhereUniqueInput
  }


  /**
   * Modulo updateMany
   */
  export type ModuloUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modulos.
     */
    data: XOR<ModuloUpdateManyMutationInput, ModuloUncheckedUpdateManyInput>
    /**
     * Filter which Modulos to update
     */
    where?: ModuloWhereInput
  }


  /**
   * Modulo upsert
   */
  export type ModuloUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * The filter to search for the Modulo to update in case it exists.
     */
    where: ModuloWhereUniqueInput
    /**
     * In case the Modulo found by the `where` argument doesn't exist, create a new Modulo with this data.
     */
    create: XOR<ModuloCreateInput, ModuloUncheckedCreateInput>
    /**
     * In case the Modulo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuloUpdateInput, ModuloUncheckedUpdateInput>
  }


  /**
   * Modulo delete
   */
  export type ModuloDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
    /**
     * Filter which Modulo to delete.
     */
    where: ModuloWhereUniqueInput
  }


  /**
   * Modulo deleteMany
   */
  export type ModuloDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modulos to delete
     */
    where?: ModuloWhereInput
  }


  /**
   * Modulo without action
   */
  export type ModuloDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modulo
     */
    select?: ModuloSelect<ExtArgs> | null
  }



  /**
   * Model Premio
   */

  export type AggregatePremio = {
    _count: PremioCountAggregateOutputType | null
    _avg: PremioAvgAggregateOutputType | null
    _sum: PremioSumAggregateOutputType | null
    _min: PremioMinAggregateOutputType | null
    _max: PremioMaxAggregateOutputType | null
  }

  export type PremioAvgAggregateOutputType = {
    IdPremio: number | null
    IdSorteo: number | null
    Lugar: number | null
    Estatus: number | null
  }

  export type PremioSumAggregateOutputType = {
    IdPremio: number | null
    IdSorteo: number | null
    Lugar: number | null
    Estatus: number | null
  }

  export type PremioMinAggregateOutputType = {
    IdPremio: number | null
    IdSorteo: number | null
    Descripcion: string | null
    Lugar: number | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type PremioMaxAggregateOutputType = {
    IdPremio: number | null
    IdSorteo: number | null
    Descripcion: string | null
    Lugar: number | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type PremioCountAggregateOutputType = {
    IdPremio: number
    IdSorteo: number
    Descripcion: number
    Lugar: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type PremioAvgAggregateInputType = {
    IdPremio?: true
    IdSorteo?: true
    Lugar?: true
    Estatus?: true
  }

  export type PremioSumAggregateInputType = {
    IdPremio?: true
    IdSorteo?: true
    Lugar?: true
    Estatus?: true
  }

  export type PremioMinAggregateInputType = {
    IdPremio?: true
    IdSorteo?: true
    Descripcion?: true
    Lugar?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type PremioMaxAggregateInputType = {
    IdPremio?: true
    IdSorteo?: true
    Descripcion?: true
    Lugar?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type PremioCountAggregateInputType = {
    IdPremio?: true
    IdSorteo?: true
    Descripcion?: true
    Lugar?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type PremioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Premio to aggregate.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Premios
    **/
    _count?: true | PremioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PremioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PremioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PremioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PremioMaxAggregateInputType
  }

  export type GetPremioAggregateType<T extends PremioAggregateArgs> = {
        [P in keyof T & keyof AggregatePremio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePremio[P]>
      : GetScalarType<T[P], AggregatePremio[P]>
  }




  export type PremioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PremioWhereInput
    orderBy?: PremioOrderByWithAggregationInput | PremioOrderByWithAggregationInput[]
    by: PremioScalarFieldEnum[] | PremioScalarFieldEnum
    having?: PremioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PremioCountAggregateInputType | true
    _avg?: PremioAvgAggregateInputType
    _sum?: PremioSumAggregateInputType
    _min?: PremioMinAggregateInputType
    _max?: PremioMaxAggregateInputType
  }

  export type PremioGroupByOutputType = {
    IdPremio: number
    IdSorteo: number
    Descripcion: string
    Lugar: number
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: PremioCountAggregateOutputType | null
    _avg: PremioAvgAggregateOutputType | null
    _sum: PremioSumAggregateOutputType | null
    _min: PremioMinAggregateOutputType | null
    _max: PremioMaxAggregateOutputType | null
  }

  type GetPremioGroupByPayload<T extends PremioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PremioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PremioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PremioGroupByOutputType[P]>
            : GetScalarType<T[P], PremioGroupByOutputType[P]>
        }
      >
    >


  export type PremioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdPremio?: boolean
    IdSorteo?: boolean
    Descripcion?: boolean
    Lugar?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }, ExtArgs["result"]["premio"]>

  export type PremioSelectScalar = {
    IdPremio?: boolean
    IdSorteo?: boolean
    Descripcion?: boolean
    Lugar?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }


  export type $PremioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Premio"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdPremio: number
      IdSorteo: number
      Descripcion: string
      Lugar: number
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["premio"]>
    composites: {}
  }


  type PremioGetPayload<S extends boolean | null | undefined | PremioDefaultArgs> = $Result.GetResult<Prisma.$PremioPayload, S>

  type PremioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PremioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PremioCountAggregateInputType | true
    }

  export interface PremioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Premio'], meta: { name: 'Premio' } }
    /**
     * Find zero or one Premio that matches the filter.
     * @param {PremioFindUniqueArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PremioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PremioFindUniqueArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Premio that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PremioFindUniqueOrThrowArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PremioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PremioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Premio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioFindFirstArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PremioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PremioFindFirstArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Premio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioFindFirstOrThrowArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PremioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PremioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Premios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Premios
     * const premios = await prisma.premio.findMany()
     * 
     * // Get first 10 Premios
     * const premios = await prisma.premio.findMany({ take: 10 })
     * 
     * // Only select the `IdPremio`
     * const premioWithIdPremioOnly = await prisma.premio.findMany({ select: { IdPremio: true } })
     * 
    **/
    findMany<T extends PremioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PremioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Premio.
     * @param {PremioCreateArgs} args - Arguments to create a Premio.
     * @example
     * // Create one Premio
     * const Premio = await prisma.premio.create({
     *   data: {
     *     // ... data to create a Premio
     *   }
     * })
     * 
    **/
    create<T extends PremioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PremioCreateArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Premios.
     *     @param {PremioCreateManyArgs} args - Arguments to create many Premios.
     *     @example
     *     // Create many Premios
     *     const premio = await prisma.premio.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PremioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PremioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Premio.
     * @param {PremioDeleteArgs} args - Arguments to delete one Premio.
     * @example
     * // Delete one Premio
     * const Premio = await prisma.premio.delete({
     *   where: {
     *     // ... filter to delete one Premio
     *   }
     * })
     * 
    **/
    delete<T extends PremioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PremioDeleteArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Premio.
     * @param {PremioUpdateArgs} args - Arguments to update one Premio.
     * @example
     * // Update one Premio
     * const premio = await prisma.premio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PremioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PremioUpdateArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Premios.
     * @param {PremioDeleteManyArgs} args - Arguments to filter Premios to delete.
     * @example
     * // Delete a few Premios
     * const { count } = await prisma.premio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PremioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PremioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Premios
     * const premio = await prisma.premio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PremioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PremioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Premio.
     * @param {PremioUpsertArgs} args - Arguments to update or create a Premio.
     * @example
     * // Update or create a Premio
     * const premio = await prisma.premio.upsert({
     *   create: {
     *     // ... data to create a Premio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Premio we want to update
     *   }
     * })
    **/
    upsert<T extends PremioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PremioUpsertArgs<ExtArgs>>
    ): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioCountArgs} args - Arguments to filter Premios to count.
     * @example
     * // Count the number of Premios
     * const count = await prisma.premio.count({
     *   where: {
     *     // ... the filter for the Premios we want to count
     *   }
     * })
    **/
    count<T extends PremioCountArgs>(
      args?: Subset<T, PremioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PremioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Premio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PremioAggregateArgs>(args: Subset<T, PremioAggregateArgs>): Prisma.PrismaPromise<GetPremioAggregateType<T>>

    /**
     * Group by Premio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PremioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PremioGroupByArgs['orderBy'] }
        : { orderBy?: PremioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PremioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPremioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Premio model
   */
  readonly fields: PremioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Premio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PremioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Premio model
   */ 
  interface PremioFieldRefs {
    readonly IdPremio: FieldRef<"Premio", 'Int'>
    readonly IdSorteo: FieldRef<"Premio", 'Int'>
    readonly Descripcion: FieldRef<"Premio", 'String'>
    readonly Lugar: FieldRef<"Premio", 'Int'>
    readonly FechaCreacion: FieldRef<"Premio", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Premio", 'DateTime'>
    readonly Estatus: FieldRef<"Premio", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Premio findUnique
   */
  export type PremioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where: PremioWhereUniqueInput
  }


  /**
   * Premio findUniqueOrThrow
   */
  export type PremioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where: PremioWhereUniqueInput
  }


  /**
   * Premio findFirst
   */
  export type PremioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Premios.
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Premios.
     */
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }


  /**
   * Premio findFirstOrThrow
   */
  export type PremioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Premios.
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Premios.
     */
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }


  /**
   * Premio findMany
   */
  export type PremioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Filter, which Premios to fetch.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Premios.
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }


  /**
   * Premio create
   */
  export type PremioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * The data needed to create a Premio.
     */
    data: XOR<PremioCreateInput, PremioUncheckedCreateInput>
  }


  /**
   * Premio createMany
   */
  export type PremioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Premios.
     */
    data: PremioCreateManyInput | PremioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Premio update
   */
  export type PremioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * The data needed to update a Premio.
     */
    data: XOR<PremioUpdateInput, PremioUncheckedUpdateInput>
    /**
     * Choose, which Premio to update.
     */
    where: PremioWhereUniqueInput
  }


  /**
   * Premio updateMany
   */
  export type PremioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Premios.
     */
    data: XOR<PremioUpdateManyMutationInput, PremioUncheckedUpdateManyInput>
    /**
     * Filter which Premios to update
     */
    where?: PremioWhereInput
  }


  /**
   * Premio upsert
   */
  export type PremioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * The filter to search for the Premio to update in case it exists.
     */
    where: PremioWhereUniqueInput
    /**
     * In case the Premio found by the `where` argument doesn't exist, create a new Premio with this data.
     */
    create: XOR<PremioCreateInput, PremioUncheckedCreateInput>
    /**
     * In case the Premio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PremioUpdateInput, PremioUncheckedUpdateInput>
  }


  /**
   * Premio delete
   */
  export type PremioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Filter which Premio to delete.
     */
    where: PremioWhereUniqueInput
  }


  /**
   * Premio deleteMany
   */
  export type PremioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Premios to delete
     */
    where?: PremioWhereInput
  }


  /**
   * Premio without action
   */
  export type PremioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
  }



  /**
   * Model Sesion
   */

  export type AggregateSesion = {
    _count: SesionCountAggregateOutputType | null
    _min: SesionMinAggregateOutputType | null
    _max: SesionMaxAggregateOutputType | null
  }

  export type SesionMinAggregateOutputType = {
    Correo: string | null
    Token: string | null
  }

  export type SesionMaxAggregateOutputType = {
    Correo: string | null
    Token: string | null
  }

  export type SesionCountAggregateOutputType = {
    Correo: number
    Token: number
    _all: number
  }


  export type SesionMinAggregateInputType = {
    Correo?: true
    Token?: true
  }

  export type SesionMaxAggregateInputType = {
    Correo?: true
    Token?: true
  }

  export type SesionCountAggregateInputType = {
    Correo?: true
    Token?: true
    _all?: true
  }

  export type SesionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sesion to aggregate.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sesions
    **/
    _count?: true | SesionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SesionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SesionMaxAggregateInputType
  }

  export type GetSesionAggregateType<T extends SesionAggregateArgs> = {
        [P in keyof T & keyof AggregateSesion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSesion[P]>
      : GetScalarType<T[P], AggregateSesion[P]>
  }




  export type SesionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SesionWhereInput
    orderBy?: SesionOrderByWithAggregationInput | SesionOrderByWithAggregationInput[]
    by: SesionScalarFieldEnum[] | SesionScalarFieldEnum
    having?: SesionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SesionCountAggregateInputType | true
    _min?: SesionMinAggregateInputType
    _max?: SesionMaxAggregateInputType
  }

  export type SesionGroupByOutputType = {
    Correo: string
    Token: string | null
    _count: SesionCountAggregateOutputType | null
    _min: SesionMinAggregateOutputType | null
    _max: SesionMaxAggregateOutputType | null
  }

  type GetSesionGroupByPayload<T extends SesionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SesionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SesionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SesionGroupByOutputType[P]>
            : GetScalarType<T[P], SesionGroupByOutputType[P]>
        }
      >
    >


  export type SesionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Correo?: boolean
    Token?: boolean
  }, ExtArgs["result"]["sesion"]>

  export type SesionSelectScalar = {
    Correo?: boolean
    Token?: boolean
  }


  export type $SesionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sesion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Correo: string
      Token: string | null
    }, ExtArgs["result"]["sesion"]>
    composites: {}
  }


  type SesionGetPayload<S extends boolean | null | undefined | SesionDefaultArgs> = $Result.GetResult<Prisma.$SesionPayload, S>

  type SesionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SesionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SesionCountAggregateInputType | true
    }

  export interface SesionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sesion'], meta: { name: 'Sesion' } }
    /**
     * Find zero or one Sesion that matches the filter.
     * @param {SesionFindUniqueArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SesionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SesionFindUniqueArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sesion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SesionFindUniqueOrThrowArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SesionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SesionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sesion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindFirstArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SesionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SesionFindFirstArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sesion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindFirstOrThrowArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SesionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SesionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sesions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sesions
     * const sesions = await prisma.sesion.findMany()
     * 
     * // Get first 10 Sesions
     * const sesions = await prisma.sesion.findMany({ take: 10 })
     * 
     * // Only select the `Correo`
     * const sesionWithCorreoOnly = await prisma.sesion.findMany({ select: { Correo: true } })
     * 
    **/
    findMany<T extends SesionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SesionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sesion.
     * @param {SesionCreateArgs} args - Arguments to create a Sesion.
     * @example
     * // Create one Sesion
     * const Sesion = await prisma.sesion.create({
     *   data: {
     *     // ... data to create a Sesion
     *   }
     * })
     * 
    **/
    create<T extends SesionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SesionCreateArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sesions.
     *     @param {SesionCreateManyArgs} args - Arguments to create many Sesions.
     *     @example
     *     // Create many Sesions
     *     const sesion = await prisma.sesion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SesionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SesionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sesion.
     * @param {SesionDeleteArgs} args - Arguments to delete one Sesion.
     * @example
     * // Delete one Sesion
     * const Sesion = await prisma.sesion.delete({
     *   where: {
     *     // ... filter to delete one Sesion
     *   }
     * })
     * 
    **/
    delete<T extends SesionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SesionDeleteArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sesion.
     * @param {SesionUpdateArgs} args - Arguments to update one Sesion.
     * @example
     * // Update one Sesion
     * const sesion = await prisma.sesion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SesionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SesionUpdateArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sesions.
     * @param {SesionDeleteManyArgs} args - Arguments to filter Sesions to delete.
     * @example
     * // Delete a few Sesions
     * const { count } = await prisma.sesion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SesionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SesionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sesions
     * const sesion = await prisma.sesion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SesionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SesionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sesion.
     * @param {SesionUpsertArgs} args - Arguments to update or create a Sesion.
     * @example
     * // Update or create a Sesion
     * const sesion = await prisma.sesion.upsert({
     *   create: {
     *     // ... data to create a Sesion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sesion we want to update
     *   }
     * })
    **/
    upsert<T extends SesionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SesionUpsertArgs<ExtArgs>>
    ): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionCountArgs} args - Arguments to filter Sesions to count.
     * @example
     * // Count the number of Sesions
     * const count = await prisma.sesion.count({
     *   where: {
     *     // ... the filter for the Sesions we want to count
     *   }
     * })
    **/
    count<T extends SesionCountArgs>(
      args?: Subset<T, SesionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SesionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SesionAggregateArgs>(args: Subset<T, SesionAggregateArgs>): Prisma.PrismaPromise<GetSesionAggregateType<T>>

    /**
     * Group by Sesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SesionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SesionGroupByArgs['orderBy'] }
        : { orderBy?: SesionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SesionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSesionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sesion model
   */
  readonly fields: SesionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sesion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SesionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sesion model
   */ 
  interface SesionFieldRefs {
    readonly Correo: FieldRef<"Sesion", 'String'>
    readonly Token: FieldRef<"Sesion", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Sesion findUnique
   */
  export type SesionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where: SesionWhereUniqueInput
  }


  /**
   * Sesion findUniqueOrThrow
   */
  export type SesionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where: SesionWhereUniqueInput
  }


  /**
   * Sesion findFirst
   */
  export type SesionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sesions.
     */
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }


  /**
   * Sesion findFirstOrThrow
   */
  export type SesionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sesions.
     */
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }


  /**
   * Sesion findMany
   */
  export type SesionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Filter, which Sesions to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }


  /**
   * Sesion create
   */
  export type SesionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * The data needed to create a Sesion.
     */
    data: XOR<SesionCreateInput, SesionUncheckedCreateInput>
  }


  /**
   * Sesion createMany
   */
  export type SesionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sesions.
     */
    data: SesionCreateManyInput | SesionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Sesion update
   */
  export type SesionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * The data needed to update a Sesion.
     */
    data: XOR<SesionUpdateInput, SesionUncheckedUpdateInput>
    /**
     * Choose, which Sesion to update.
     */
    where: SesionWhereUniqueInput
  }


  /**
   * Sesion updateMany
   */
  export type SesionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sesions.
     */
    data: XOR<SesionUpdateManyMutationInput, SesionUncheckedUpdateManyInput>
    /**
     * Filter which Sesions to update
     */
    where?: SesionWhereInput
  }


  /**
   * Sesion upsert
   */
  export type SesionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * The filter to search for the Sesion to update in case it exists.
     */
    where: SesionWhereUniqueInput
    /**
     * In case the Sesion found by the `where` argument doesn't exist, create a new Sesion with this data.
     */
    create: XOR<SesionCreateInput, SesionUncheckedCreateInput>
    /**
     * In case the Sesion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SesionUpdateInput, SesionUncheckedUpdateInput>
  }


  /**
   * Sesion delete
   */
  export type SesionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Filter which Sesion to delete.
     */
    where: SesionWhereUniqueInput
  }


  /**
   * Sesion deleteMany
   */
  export type SesionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sesions to delete
     */
    where?: SesionWhereInput
  }


  /**
   * Sesion without action
   */
  export type SesionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
  }



  /**
   * Model Sorteo
   */

  export type AggregateSorteo = {
    _count: SorteoCountAggregateOutputType | null
    _avg: SorteoAvgAggregateOutputType | null
    _sum: SorteoSumAggregateOutputType | null
    _min: SorteoMinAggregateOutputType | null
    _max: SorteoMaxAggregateOutputType | null
  }

  export type SorteoAvgAggregateOutputType = {
    IdSorteo: number | null
    Estatus: number | null
  }

  export type SorteoSumAggregateOutputType = {
    IdSorteo: number | null
    Estatus: number | null
  }

  export type SorteoMinAggregateOutputType = {
    IdSorteo: number | null
    Nombre: string | null
    FechaSorteo: Date | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type SorteoMaxAggregateOutputType = {
    IdSorteo: number | null
    Nombre: string | null
    FechaSorteo: Date | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type SorteoCountAggregateOutputType = {
    IdSorteo: number
    Nombre: number
    FechaSorteo: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type SorteoAvgAggregateInputType = {
    IdSorteo?: true
    Estatus?: true
  }

  export type SorteoSumAggregateInputType = {
    IdSorteo?: true
    Estatus?: true
  }

  export type SorteoMinAggregateInputType = {
    IdSorteo?: true
    Nombre?: true
    FechaSorteo?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type SorteoMaxAggregateInputType = {
    IdSorteo?: true
    Nombre?: true
    FechaSorteo?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type SorteoCountAggregateInputType = {
    IdSorteo?: true
    Nombre?: true
    FechaSorteo?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type SorteoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sorteo to aggregate.
     */
    where?: SorteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorteos to fetch.
     */
    orderBy?: SorteoOrderByWithRelationInput | SorteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SorteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorteos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sorteos
    **/
    _count?: true | SorteoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SorteoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SorteoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SorteoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SorteoMaxAggregateInputType
  }

  export type GetSorteoAggregateType<T extends SorteoAggregateArgs> = {
        [P in keyof T & keyof AggregateSorteo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSorteo[P]>
      : GetScalarType<T[P], AggregateSorteo[P]>
  }




  export type SorteoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SorteoWhereInput
    orderBy?: SorteoOrderByWithAggregationInput | SorteoOrderByWithAggregationInput[]
    by: SorteoScalarFieldEnum[] | SorteoScalarFieldEnum
    having?: SorteoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SorteoCountAggregateInputType | true
    _avg?: SorteoAvgAggregateInputType
    _sum?: SorteoSumAggregateInputType
    _min?: SorteoMinAggregateInputType
    _max?: SorteoMaxAggregateInputType
  }

  export type SorteoGroupByOutputType = {
    IdSorteo: number
    Nombre: string
    FechaSorteo: Date
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: SorteoCountAggregateOutputType | null
    _avg: SorteoAvgAggregateOutputType | null
    _sum: SorteoSumAggregateOutputType | null
    _min: SorteoMinAggregateOutputType | null
    _max: SorteoMaxAggregateOutputType | null
  }

  type GetSorteoGroupByPayload<T extends SorteoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SorteoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SorteoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SorteoGroupByOutputType[P]>
            : GetScalarType<T[P], SorteoGroupByOutputType[P]>
        }
      >
    >


  export type SorteoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdSorteo?: boolean
    Nombre?: boolean
    FechaSorteo?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }, ExtArgs["result"]["sorteo"]>

  export type SorteoSelectScalar = {
    IdSorteo?: boolean
    Nombre?: boolean
    FechaSorteo?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }


  export type $SorteoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sorteo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdSorteo: number
      Nombre: string
      FechaSorteo: Date
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["sorteo"]>
    composites: {}
  }


  type SorteoGetPayload<S extends boolean | null | undefined | SorteoDefaultArgs> = $Result.GetResult<Prisma.$SorteoPayload, S>

  type SorteoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SorteoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SorteoCountAggregateInputType | true
    }

  export interface SorteoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sorteo'], meta: { name: 'Sorteo' } }
    /**
     * Find zero or one Sorteo that matches the filter.
     * @param {SorteoFindUniqueArgs} args - Arguments to find a Sorteo
     * @example
     * // Get one Sorteo
     * const sorteo = await prisma.sorteo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SorteoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SorteoFindUniqueArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sorteo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SorteoFindUniqueOrThrowArgs} args - Arguments to find a Sorteo
     * @example
     * // Get one Sorteo
     * const sorteo = await prisma.sorteo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SorteoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SorteoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sorteo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoFindFirstArgs} args - Arguments to find a Sorteo
     * @example
     * // Get one Sorteo
     * const sorteo = await prisma.sorteo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SorteoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SorteoFindFirstArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sorteo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoFindFirstOrThrowArgs} args - Arguments to find a Sorteo
     * @example
     * // Get one Sorteo
     * const sorteo = await prisma.sorteo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SorteoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SorteoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sorteos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sorteos
     * const sorteos = await prisma.sorteo.findMany()
     * 
     * // Get first 10 Sorteos
     * const sorteos = await prisma.sorteo.findMany({ take: 10 })
     * 
     * // Only select the `IdSorteo`
     * const sorteoWithIdSorteoOnly = await prisma.sorteo.findMany({ select: { IdSorteo: true } })
     * 
    **/
    findMany<T extends SorteoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SorteoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sorteo.
     * @param {SorteoCreateArgs} args - Arguments to create a Sorteo.
     * @example
     * // Create one Sorteo
     * const Sorteo = await prisma.sorteo.create({
     *   data: {
     *     // ... data to create a Sorteo
     *   }
     * })
     * 
    **/
    create<T extends SorteoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SorteoCreateArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sorteos.
     *     @param {SorteoCreateManyArgs} args - Arguments to create many Sorteos.
     *     @example
     *     // Create many Sorteos
     *     const sorteo = await prisma.sorteo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SorteoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SorteoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sorteo.
     * @param {SorteoDeleteArgs} args - Arguments to delete one Sorteo.
     * @example
     * // Delete one Sorteo
     * const Sorteo = await prisma.sorteo.delete({
     *   where: {
     *     // ... filter to delete one Sorteo
     *   }
     * })
     * 
    **/
    delete<T extends SorteoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SorteoDeleteArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sorteo.
     * @param {SorteoUpdateArgs} args - Arguments to update one Sorteo.
     * @example
     * // Update one Sorteo
     * const sorteo = await prisma.sorteo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SorteoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SorteoUpdateArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sorteos.
     * @param {SorteoDeleteManyArgs} args - Arguments to filter Sorteos to delete.
     * @example
     * // Delete a few Sorteos
     * const { count } = await prisma.sorteo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SorteoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SorteoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sorteos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sorteos
     * const sorteo = await prisma.sorteo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SorteoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SorteoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sorteo.
     * @param {SorteoUpsertArgs} args - Arguments to update or create a Sorteo.
     * @example
     * // Update or create a Sorteo
     * const sorteo = await prisma.sorteo.upsert({
     *   create: {
     *     // ... data to create a Sorteo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sorteo we want to update
     *   }
     * })
    **/
    upsert<T extends SorteoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SorteoUpsertArgs<ExtArgs>>
    ): Prisma__SorteoClient<$Result.GetResult<Prisma.$SorteoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sorteos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoCountArgs} args - Arguments to filter Sorteos to count.
     * @example
     * // Count the number of Sorteos
     * const count = await prisma.sorteo.count({
     *   where: {
     *     // ... the filter for the Sorteos we want to count
     *   }
     * })
    **/
    count<T extends SorteoCountArgs>(
      args?: Subset<T, SorteoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SorteoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sorteo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SorteoAggregateArgs>(args: Subset<T, SorteoAggregateArgs>): Prisma.PrismaPromise<GetSorteoAggregateType<T>>

    /**
     * Group by Sorteo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SorteoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SorteoGroupByArgs['orderBy'] }
        : { orderBy?: SorteoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SorteoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSorteoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sorteo model
   */
  readonly fields: SorteoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sorteo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SorteoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sorteo model
   */ 
  interface SorteoFieldRefs {
    readonly IdSorteo: FieldRef<"Sorteo", 'Int'>
    readonly Nombre: FieldRef<"Sorteo", 'String'>
    readonly FechaSorteo: FieldRef<"Sorteo", 'DateTime'>
    readonly FechaCreacion: FieldRef<"Sorteo", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Sorteo", 'DateTime'>
    readonly Estatus: FieldRef<"Sorteo", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Sorteo findUnique
   */
  export type SorteoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * Filter, which Sorteo to fetch.
     */
    where: SorteoWhereUniqueInput
  }


  /**
   * Sorteo findUniqueOrThrow
   */
  export type SorteoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * Filter, which Sorteo to fetch.
     */
    where: SorteoWhereUniqueInput
  }


  /**
   * Sorteo findFirst
   */
  export type SorteoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * Filter, which Sorteo to fetch.
     */
    where?: SorteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorteos to fetch.
     */
    orderBy?: SorteoOrderByWithRelationInput | SorteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sorteos.
     */
    cursor?: SorteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorteos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sorteos.
     */
    distinct?: SorteoScalarFieldEnum | SorteoScalarFieldEnum[]
  }


  /**
   * Sorteo findFirstOrThrow
   */
  export type SorteoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * Filter, which Sorteo to fetch.
     */
    where?: SorteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorteos to fetch.
     */
    orderBy?: SorteoOrderByWithRelationInput | SorteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sorteos.
     */
    cursor?: SorteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorteos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sorteos.
     */
    distinct?: SorteoScalarFieldEnum | SorteoScalarFieldEnum[]
  }


  /**
   * Sorteo findMany
   */
  export type SorteoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * Filter, which Sorteos to fetch.
     */
    where?: SorteoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sorteos to fetch.
     */
    orderBy?: SorteoOrderByWithRelationInput | SorteoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sorteos.
     */
    cursor?: SorteoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sorteos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sorteos.
     */
    skip?: number
    distinct?: SorteoScalarFieldEnum | SorteoScalarFieldEnum[]
  }


  /**
   * Sorteo create
   */
  export type SorteoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * The data needed to create a Sorteo.
     */
    data: XOR<SorteoCreateInput, SorteoUncheckedCreateInput>
  }


  /**
   * Sorteo createMany
   */
  export type SorteoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sorteos.
     */
    data: SorteoCreateManyInput | SorteoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Sorteo update
   */
  export type SorteoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * The data needed to update a Sorteo.
     */
    data: XOR<SorteoUpdateInput, SorteoUncheckedUpdateInput>
    /**
     * Choose, which Sorteo to update.
     */
    where: SorteoWhereUniqueInput
  }


  /**
   * Sorteo updateMany
   */
  export type SorteoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sorteos.
     */
    data: XOR<SorteoUpdateManyMutationInput, SorteoUncheckedUpdateManyInput>
    /**
     * Filter which Sorteos to update
     */
    where?: SorteoWhereInput
  }


  /**
   * Sorteo upsert
   */
  export type SorteoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * The filter to search for the Sorteo to update in case it exists.
     */
    where: SorteoWhereUniqueInput
    /**
     * In case the Sorteo found by the `where` argument doesn't exist, create a new Sorteo with this data.
     */
    create: XOR<SorteoCreateInput, SorteoUncheckedCreateInput>
    /**
     * In case the Sorteo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SorteoUpdateInput, SorteoUncheckedUpdateInput>
  }


  /**
   * Sorteo delete
   */
  export type SorteoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
    /**
     * Filter which Sorteo to delete.
     */
    where: SorteoWhereUniqueInput
  }


  /**
   * Sorteo deleteMany
   */
  export type SorteoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sorteos to delete
     */
    where?: SorteoWhereInput
  }


  /**
   * Sorteo without action
   */
  export type SorteoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sorteo
     */
    select?: SorteoSelect<ExtArgs> | null
  }



  /**
   * Model TipoLogin
   */

  export type AggregateTipoLogin = {
    _count: TipoLoginCountAggregateOutputType | null
    _avg: TipoLoginAvgAggregateOutputType | null
    _sum: TipoLoginSumAggregateOutputType | null
    _min: TipoLoginMinAggregateOutputType | null
    _max: TipoLoginMaxAggregateOutputType | null
  }

  export type TipoLoginAvgAggregateOutputType = {
    IdTipoLogin: number | null
    Estatus: number | null
  }

  export type TipoLoginSumAggregateOutputType = {
    IdTipoLogin: number | null
    Estatus: number | null
  }

  export type TipoLoginMinAggregateOutputType = {
    IdTipoLogin: number | null
    Descripcion: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type TipoLoginMaxAggregateOutputType = {
    IdTipoLogin: number | null
    Descripcion: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type TipoLoginCountAggregateOutputType = {
    IdTipoLogin: number
    Descripcion: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type TipoLoginAvgAggregateInputType = {
    IdTipoLogin?: true
    Estatus?: true
  }

  export type TipoLoginSumAggregateInputType = {
    IdTipoLogin?: true
    Estatus?: true
  }

  export type TipoLoginMinAggregateInputType = {
    IdTipoLogin?: true
    Descripcion?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type TipoLoginMaxAggregateInputType = {
    IdTipoLogin?: true
    Descripcion?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type TipoLoginCountAggregateInputType = {
    IdTipoLogin?: true
    Descripcion?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type TipoLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoLogin to aggregate.
     */
    where?: TipoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoLogins to fetch.
     */
    orderBy?: TipoLoginOrderByWithRelationInput | TipoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoLogins
    **/
    _count?: true | TipoLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoLoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoLoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoLoginMaxAggregateInputType
  }

  export type GetTipoLoginAggregateType<T extends TipoLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoLogin[P]>
      : GetScalarType<T[P], AggregateTipoLogin[P]>
  }




  export type TipoLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoLoginWhereInput
    orderBy?: TipoLoginOrderByWithAggregationInput | TipoLoginOrderByWithAggregationInput[]
    by: TipoLoginScalarFieldEnum[] | TipoLoginScalarFieldEnum
    having?: TipoLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoLoginCountAggregateInputType | true
    _avg?: TipoLoginAvgAggregateInputType
    _sum?: TipoLoginSumAggregateInputType
    _min?: TipoLoginMinAggregateInputType
    _max?: TipoLoginMaxAggregateInputType
  }

  export type TipoLoginGroupByOutputType = {
    IdTipoLogin: number
    Descripcion: string
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: TipoLoginCountAggregateOutputType | null
    _avg: TipoLoginAvgAggregateOutputType | null
    _sum: TipoLoginSumAggregateOutputType | null
    _min: TipoLoginMinAggregateOutputType | null
    _max: TipoLoginMaxAggregateOutputType | null
  }

  type GetTipoLoginGroupByPayload<T extends TipoLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoLoginGroupByOutputType[P]>
            : GetScalarType<T[P], TipoLoginGroupByOutputType[P]>
        }
      >
    >


  export type TipoLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdTipoLogin?: boolean
    Descripcion?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }, ExtArgs["result"]["tipoLogin"]>

  export type TipoLoginSelectScalar = {
    IdTipoLogin?: boolean
    Descripcion?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }


  export type $TipoLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoLogin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IdTipoLogin: number
      Descripcion: string
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["tipoLogin"]>
    composites: {}
  }


  type TipoLoginGetPayload<S extends boolean | null | undefined | TipoLoginDefaultArgs> = $Result.GetResult<Prisma.$TipoLoginPayload, S>

  type TipoLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TipoLoginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TipoLoginCountAggregateInputType | true
    }

  export interface TipoLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoLogin'], meta: { name: 'TipoLogin' } }
    /**
     * Find zero or one TipoLogin that matches the filter.
     * @param {TipoLoginFindUniqueArgs} args - Arguments to find a TipoLogin
     * @example
     * // Get one TipoLogin
     * const tipoLogin = await prisma.tipoLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TipoLoginFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TipoLoginFindUniqueArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TipoLogin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TipoLoginFindUniqueOrThrowArgs} args - Arguments to find a TipoLogin
     * @example
     * // Get one TipoLogin
     * const tipoLogin = await prisma.tipoLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TipoLoginFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoLoginFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TipoLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginFindFirstArgs} args - Arguments to find a TipoLogin
     * @example
     * // Get one TipoLogin
     * const tipoLogin = await prisma.tipoLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TipoLoginFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoLoginFindFirstArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TipoLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginFindFirstOrThrowArgs} args - Arguments to find a TipoLogin
     * @example
     * // Get one TipoLogin
     * const tipoLogin = await prisma.tipoLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TipoLoginFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoLoginFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TipoLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoLogins
     * const tipoLogins = await prisma.tipoLogin.findMany()
     * 
     * // Get first 10 TipoLogins
     * const tipoLogins = await prisma.tipoLogin.findMany({ take: 10 })
     * 
     * // Only select the `IdTipoLogin`
     * const tipoLoginWithIdTipoLoginOnly = await prisma.tipoLogin.findMany({ select: { IdTipoLogin: true } })
     * 
    **/
    findMany<T extends TipoLoginFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoLoginFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TipoLogin.
     * @param {TipoLoginCreateArgs} args - Arguments to create a TipoLogin.
     * @example
     * // Create one TipoLogin
     * const TipoLogin = await prisma.tipoLogin.create({
     *   data: {
     *     // ... data to create a TipoLogin
     *   }
     * })
     * 
    **/
    create<T extends TipoLoginCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TipoLoginCreateArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TipoLogins.
     *     @param {TipoLoginCreateManyArgs} args - Arguments to create many TipoLogins.
     *     @example
     *     // Create many TipoLogins
     *     const tipoLogin = await prisma.tipoLogin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TipoLoginCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoLoginCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TipoLogin.
     * @param {TipoLoginDeleteArgs} args - Arguments to delete one TipoLogin.
     * @example
     * // Delete one TipoLogin
     * const TipoLogin = await prisma.tipoLogin.delete({
     *   where: {
     *     // ... filter to delete one TipoLogin
     *   }
     * })
     * 
    **/
    delete<T extends TipoLoginDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TipoLoginDeleteArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TipoLogin.
     * @param {TipoLoginUpdateArgs} args - Arguments to update one TipoLogin.
     * @example
     * // Update one TipoLogin
     * const tipoLogin = await prisma.tipoLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TipoLoginUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TipoLoginUpdateArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TipoLogins.
     * @param {TipoLoginDeleteManyArgs} args - Arguments to filter TipoLogins to delete.
     * @example
     * // Delete a few TipoLogins
     * const { count } = await prisma.tipoLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TipoLoginDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TipoLoginDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoLogins
     * const tipoLogin = await prisma.tipoLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TipoLoginUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TipoLoginUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoLogin.
     * @param {TipoLoginUpsertArgs} args - Arguments to update or create a TipoLogin.
     * @example
     * // Update or create a TipoLogin
     * const tipoLogin = await prisma.tipoLogin.upsert({
     *   create: {
     *     // ... data to create a TipoLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoLogin we want to update
     *   }
     * })
    **/
    upsert<T extends TipoLoginUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TipoLoginUpsertArgs<ExtArgs>>
    ): Prisma__TipoLoginClient<$Result.GetResult<Prisma.$TipoLoginPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TipoLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginCountArgs} args - Arguments to filter TipoLogins to count.
     * @example
     * // Count the number of TipoLogins
     * const count = await prisma.tipoLogin.count({
     *   where: {
     *     // ... the filter for the TipoLogins we want to count
     *   }
     * })
    **/
    count<T extends TipoLoginCountArgs>(
      args?: Subset<T, TipoLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoLoginAggregateArgs>(args: Subset<T, TipoLoginAggregateArgs>): Prisma.PrismaPromise<GetTipoLoginAggregateType<T>>

    /**
     * Group by TipoLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoLoginGroupByArgs['orderBy'] }
        : { orderBy?: TipoLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoLogin model
   */
  readonly fields: TipoLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TipoLogin model
   */ 
  interface TipoLoginFieldRefs {
    readonly IdTipoLogin: FieldRef<"TipoLogin", 'Int'>
    readonly Descripcion: FieldRef<"TipoLogin", 'String'>
    readonly FechaCreacion: FieldRef<"TipoLogin", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"TipoLogin", 'DateTime'>
    readonly Estatus: FieldRef<"TipoLogin", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TipoLogin findUnique
   */
  export type TipoLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * Filter, which TipoLogin to fetch.
     */
    where: TipoLoginWhereUniqueInput
  }


  /**
   * TipoLogin findUniqueOrThrow
   */
  export type TipoLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * Filter, which TipoLogin to fetch.
     */
    where: TipoLoginWhereUniqueInput
  }


  /**
   * TipoLogin findFirst
   */
  export type TipoLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * Filter, which TipoLogin to fetch.
     */
    where?: TipoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoLogins to fetch.
     */
    orderBy?: TipoLoginOrderByWithRelationInput | TipoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoLogins.
     */
    cursor?: TipoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoLogins.
     */
    distinct?: TipoLoginScalarFieldEnum | TipoLoginScalarFieldEnum[]
  }


  /**
   * TipoLogin findFirstOrThrow
   */
  export type TipoLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * Filter, which TipoLogin to fetch.
     */
    where?: TipoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoLogins to fetch.
     */
    orderBy?: TipoLoginOrderByWithRelationInput | TipoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoLogins.
     */
    cursor?: TipoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoLogins.
     */
    distinct?: TipoLoginScalarFieldEnum | TipoLoginScalarFieldEnum[]
  }


  /**
   * TipoLogin findMany
   */
  export type TipoLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * Filter, which TipoLogins to fetch.
     */
    where?: TipoLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoLogins to fetch.
     */
    orderBy?: TipoLoginOrderByWithRelationInput | TipoLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoLogins.
     */
    cursor?: TipoLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoLogins.
     */
    skip?: number
    distinct?: TipoLoginScalarFieldEnum | TipoLoginScalarFieldEnum[]
  }


  /**
   * TipoLogin create
   */
  export type TipoLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * The data needed to create a TipoLogin.
     */
    data: XOR<TipoLoginCreateInput, TipoLoginUncheckedCreateInput>
  }


  /**
   * TipoLogin createMany
   */
  export type TipoLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoLogins.
     */
    data: TipoLoginCreateManyInput | TipoLoginCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TipoLogin update
   */
  export type TipoLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * The data needed to update a TipoLogin.
     */
    data: XOR<TipoLoginUpdateInput, TipoLoginUncheckedUpdateInput>
    /**
     * Choose, which TipoLogin to update.
     */
    where: TipoLoginWhereUniqueInput
  }


  /**
   * TipoLogin updateMany
   */
  export type TipoLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoLogins.
     */
    data: XOR<TipoLoginUpdateManyMutationInput, TipoLoginUncheckedUpdateManyInput>
    /**
     * Filter which TipoLogins to update
     */
    where?: TipoLoginWhereInput
  }


  /**
   * TipoLogin upsert
   */
  export type TipoLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * The filter to search for the TipoLogin to update in case it exists.
     */
    where: TipoLoginWhereUniqueInput
    /**
     * In case the TipoLogin found by the `where` argument doesn't exist, create a new TipoLogin with this data.
     */
    create: XOR<TipoLoginCreateInput, TipoLoginUncheckedCreateInput>
    /**
     * In case the TipoLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoLoginUpdateInput, TipoLoginUncheckedUpdateInput>
  }


  /**
   * TipoLogin delete
   */
  export type TipoLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
    /**
     * Filter which TipoLogin to delete.
     */
    where: TipoLoginWhereUniqueInput
  }


  /**
   * TipoLogin deleteMany
   */
  export type TipoLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoLogins to delete
     */
    where?: TipoLoginWhereInput
  }


  /**
   * TipoLogin without action
   */
  export type TipoLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLogin
     */
    select?: TipoLoginSelect<ExtArgs> | null
  }



  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    IdUsuario: number | null
    Estatus: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    IdUsuario: number | null
    Estatus: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    IdUsuario: number | null
    Nombre: string | null
    ApPaterno: string | null
    ApMaterno: string | null
    Telefono: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    IdUsuario: number | null
    Nombre: string | null
    ApPaterno: string | null
    ApMaterno: string | null
    Telefono: string | null
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    IdUsuario: number
    Nombre: number
    ApPaterno: number
    ApMaterno: number
    Telefono: number
    FechaCreacion: number
    FechaActualizacion: number
    Estatus: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    IdUsuario?: true
    Estatus?: true
  }

  export type UsuarioSumAggregateInputType = {
    IdUsuario?: true
    Estatus?: true
  }

  export type UsuarioMinAggregateInputType = {
    IdUsuario?: true
    Nombre?: true
    ApPaterno?: true
    ApMaterno?: true
    Telefono?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type UsuarioMaxAggregateInputType = {
    IdUsuario?: true
    Nombre?: true
    ApPaterno?: true
    ApMaterno?: true
    Telefono?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
  }

  export type UsuarioCountAggregateInputType = {
    IdUsuario?: true
    Nombre?: true
    ApPaterno?: true
    ApMaterno?: true
    Telefono?: true
    FechaCreacion?: true
    FechaActualizacion?: true
    Estatus?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    IdUsuario: number
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion: Date | null
    FechaActualizacion: Date | null
    Estatus: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IdUsuario?: boolean
    Nombre?: boolean
    ApPaterno?: boolean
    ApMaterno?: boolean
    Telefono?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
    Direccion?: boolean | Usuario$DireccionArgs<ExtArgs>
    Login?: boolean | Usuario$LoginArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    IdUsuario?: boolean
    Nombre?: boolean
    ApPaterno?: boolean
    ApMaterno?: boolean
    Telefono?: boolean
    FechaCreacion?: boolean
    FechaActualizacion?: boolean
    Estatus?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Direccion?: boolean | Usuario$DireccionArgs<ExtArgs>
    Login?: boolean | Usuario$LoginArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      Direccion: Prisma.$DireccionPayload<ExtArgs>[]
      Login: Prisma.$LoginPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      IdUsuario: number
      Nombre: string
      ApPaterno: string
      ApMaterno: string
      Telefono: string
      FechaCreacion: Date | null
      FechaActualizacion: Date | null
      Estatus: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }


  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuarioFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuarioFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `IdUsuario`
     * const usuarioWithIdUsuarioOnly = await prisma.usuario.findMany({ select: { IdUsuario: true } })
     * 
    **/
    findMany<T extends UsuarioFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuarioCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>
    ): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Direccion<T extends Usuario$DireccionArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$DireccionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DireccionPayload<ExtArgs>, T, 'findMany'> | Null>;

    Login<T extends Usuario$LoginArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$LoginArgs<ExtArgs>>): Prisma__LoginClient<$Result.GetResult<Prisma.$LoginPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly IdUsuario: FieldRef<"Usuario", 'Int'>
    readonly Nombre: FieldRef<"Usuario", 'String'>
    readonly ApPaterno: FieldRef<"Usuario", 'String'>
    readonly ApMaterno: FieldRef<"Usuario", 'String'>
    readonly Telefono: FieldRef<"Usuario", 'String'>
    readonly FechaCreacion: FieldRef<"Usuario", 'DateTime'>
    readonly FechaActualizacion: FieldRef<"Usuario", 'DateTime'>
    readonly Estatus: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }


  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }


  /**
   * Usuario.Direccion
   */
  export type Usuario$DireccionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Direccion
     */
    select?: DireccionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DireccionInclude<ExtArgs> | null
    where?: DireccionWhereInput
    orderBy?: DireccionOrderByWithRelationInput | DireccionOrderByWithRelationInput[]
    cursor?: DireccionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DireccionScalarFieldEnum | DireccionScalarFieldEnum[]
  }


  /**
   * Usuario.Login
   */
  export type Usuario$LoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Login
     */
    select?: LoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LoginInclude<ExtArgs> | null
    where?: LoginWhereInput
  }


  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsuarioInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DireccionScalarFieldEnum: {
    IdDireccion: 'IdDireccion',
    IdUsuario: 'IdUsuario',
    Calle: 'Calle',
    NumeroExt: 'NumeroExt',
    NumeroInt: 'NumeroInt',
    Colonia: 'Colonia',
    Municipio: 'Municipio',
    Estado: 'Estado',
    CP: 'CP',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type DireccionScalarFieldEnum = (typeof DireccionScalarFieldEnum)[keyof typeof DireccionScalarFieldEnum]


  export const GanadorScalarFieldEnum: {
    IdGanador: 'IdGanador',
    IdSorteo: 'IdSorteo',
    Lugar: 'Lugar',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type GanadorScalarFieldEnum = (typeof GanadorScalarFieldEnum)[keyof typeof GanadorScalarFieldEnum]


  export const LoginScalarFieldEnum: {
    IdLogin: 'IdLogin',
    IdUsuario: 'IdUsuario',
    Correo: 'Correo',
    Contrasena: 'Contrasena',
    IdTipoLogin: 'IdTipoLogin',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type LoginScalarFieldEnum = (typeof LoginScalarFieldEnum)[keyof typeof LoginScalarFieldEnum]


  export const ModuloScalarFieldEnum: {
    IdModulo: 'IdModulo',
    Descripcion: 'Descripcion',
    Icono: 'Icono',
    Ruta: 'Ruta',
    Padre: 'Padre',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type ModuloScalarFieldEnum = (typeof ModuloScalarFieldEnum)[keyof typeof ModuloScalarFieldEnum]


  export const PremioScalarFieldEnum: {
    IdPremio: 'IdPremio',
    IdSorteo: 'IdSorteo',
    Descripcion: 'Descripcion',
    Lugar: 'Lugar',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type PremioScalarFieldEnum = (typeof PremioScalarFieldEnum)[keyof typeof PremioScalarFieldEnum]


  export const SesionScalarFieldEnum: {
    Correo: 'Correo',
    Token: 'Token'
  };

  export type SesionScalarFieldEnum = (typeof SesionScalarFieldEnum)[keyof typeof SesionScalarFieldEnum]


  export const SorteoScalarFieldEnum: {
    IdSorteo: 'IdSorteo',
    Nombre: 'Nombre',
    FechaSorteo: 'FechaSorteo',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type SorteoScalarFieldEnum = (typeof SorteoScalarFieldEnum)[keyof typeof SorteoScalarFieldEnum]


  export const TipoLoginScalarFieldEnum: {
    IdTipoLogin: 'IdTipoLogin',
    Descripcion: 'Descripcion',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type TipoLoginScalarFieldEnum = (typeof TipoLoginScalarFieldEnum)[keyof typeof TipoLoginScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    IdUsuario: 'IdUsuario',
    Nombre: 'Nombre',
    ApPaterno: 'ApPaterno',
    ApMaterno: 'ApMaterno',
    Telefono: 'Telefono',
    FechaCreacion: 'FechaCreacion',
    FechaActualizacion: 'FechaActualizacion',
    Estatus: 'Estatus'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type DireccionWhereInput = {
    AND?: DireccionWhereInput | DireccionWhereInput[]
    OR?: DireccionWhereInput[]
    NOT?: DireccionWhereInput | DireccionWhereInput[]
    IdDireccion?: IntFilter<"Direccion"> | number
    IdUsuario?: IntFilter<"Direccion"> | number
    Calle?: StringFilter<"Direccion"> | string
    NumeroExt?: StringFilter<"Direccion"> | string
    NumeroInt?: StringNullableFilter<"Direccion"> | string | null
    Colonia?: StringFilter<"Direccion"> | string
    Municipio?: StringFilter<"Direccion"> | string
    Estado?: StringFilter<"Direccion"> | string
    CP?: StringFilter<"Direccion"> | string
    FechaCreacion?: DateTimeNullableFilter<"Direccion"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Direccion"> | Date | string | null
    Estatus?: IntFilter<"Direccion"> | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type DireccionOrderByWithRelationInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Calle?: SortOrder
    NumeroExt?: SortOrder
    NumeroInt?: SortOrderInput | SortOrder
    Colonia?: SortOrder
    Municipio?: SortOrder
    Estado?: SortOrder
    CP?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type DireccionWhereUniqueInput = Prisma.AtLeast<{
    IdDireccion?: number
    AND?: DireccionWhereInput | DireccionWhereInput[]
    OR?: DireccionWhereInput[]
    NOT?: DireccionWhereInput | DireccionWhereInput[]
    IdUsuario?: IntFilter<"Direccion"> | number
    Calle?: StringFilter<"Direccion"> | string
    NumeroExt?: StringFilter<"Direccion"> | string
    NumeroInt?: StringNullableFilter<"Direccion"> | string | null
    Colonia?: StringFilter<"Direccion"> | string
    Municipio?: StringFilter<"Direccion"> | string
    Estado?: StringFilter<"Direccion"> | string
    CP?: StringFilter<"Direccion"> | string
    FechaCreacion?: DateTimeNullableFilter<"Direccion"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Direccion"> | Date | string | null
    Estatus?: IntFilter<"Direccion"> | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "IdDireccion">

  export type DireccionOrderByWithAggregationInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Calle?: SortOrder
    NumeroExt?: SortOrder
    NumeroInt?: SortOrderInput | SortOrder
    Colonia?: SortOrder
    Municipio?: SortOrder
    Estado?: SortOrder
    CP?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: DireccionCountOrderByAggregateInput
    _avg?: DireccionAvgOrderByAggregateInput
    _max?: DireccionMaxOrderByAggregateInput
    _min?: DireccionMinOrderByAggregateInput
    _sum?: DireccionSumOrderByAggregateInput
  }

  export type DireccionScalarWhereWithAggregatesInput = {
    AND?: DireccionScalarWhereWithAggregatesInput | DireccionScalarWhereWithAggregatesInput[]
    OR?: DireccionScalarWhereWithAggregatesInput[]
    NOT?: DireccionScalarWhereWithAggregatesInput | DireccionScalarWhereWithAggregatesInput[]
    IdDireccion?: IntWithAggregatesFilter<"Direccion"> | number
    IdUsuario?: IntWithAggregatesFilter<"Direccion"> | number
    Calle?: StringWithAggregatesFilter<"Direccion"> | string
    NumeroExt?: StringWithAggregatesFilter<"Direccion"> | string
    NumeroInt?: StringNullableWithAggregatesFilter<"Direccion"> | string | null
    Colonia?: StringWithAggregatesFilter<"Direccion"> | string
    Municipio?: StringWithAggregatesFilter<"Direccion"> | string
    Estado?: StringWithAggregatesFilter<"Direccion"> | string
    CP?: StringWithAggregatesFilter<"Direccion"> | string
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Direccion"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Direccion"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Direccion"> | number
  }

  export type GanadorWhereInput = {
    AND?: GanadorWhereInput | GanadorWhereInput[]
    OR?: GanadorWhereInput[]
    NOT?: GanadorWhereInput | GanadorWhereInput[]
    IdGanador?: IntFilter<"Ganador"> | number
    IdSorteo?: IntFilter<"Ganador"> | number
    Lugar?: IntFilter<"Ganador"> | number
    FechaCreacion?: DateTimeNullableFilter<"Ganador"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Ganador"> | Date | string | null
    Estatus?: IntFilter<"Ganador"> | number
  }

  export type GanadorOrderByWithRelationInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
  }

  export type GanadorWhereUniqueInput = Prisma.AtLeast<{
    IdGanador?: number
    AND?: GanadorWhereInput | GanadorWhereInput[]
    OR?: GanadorWhereInput[]
    NOT?: GanadorWhereInput | GanadorWhereInput[]
    IdSorteo?: IntFilter<"Ganador"> | number
    Lugar?: IntFilter<"Ganador"> | number
    FechaCreacion?: DateTimeNullableFilter<"Ganador"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Ganador"> | Date | string | null
    Estatus?: IntFilter<"Ganador"> | number
  }, "IdGanador">

  export type GanadorOrderByWithAggregationInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: GanadorCountOrderByAggregateInput
    _avg?: GanadorAvgOrderByAggregateInput
    _max?: GanadorMaxOrderByAggregateInput
    _min?: GanadorMinOrderByAggregateInput
    _sum?: GanadorSumOrderByAggregateInput
  }

  export type GanadorScalarWhereWithAggregatesInput = {
    AND?: GanadorScalarWhereWithAggregatesInput | GanadorScalarWhereWithAggregatesInput[]
    OR?: GanadorScalarWhereWithAggregatesInput[]
    NOT?: GanadorScalarWhereWithAggregatesInput | GanadorScalarWhereWithAggregatesInput[]
    IdGanador?: IntWithAggregatesFilter<"Ganador"> | number
    IdSorteo?: IntWithAggregatesFilter<"Ganador"> | number
    Lugar?: IntWithAggregatesFilter<"Ganador"> | number
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Ganador"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Ganador"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Ganador"> | number
  }

  export type LoginWhereInput = {
    AND?: LoginWhereInput | LoginWhereInput[]
    OR?: LoginWhereInput[]
    NOT?: LoginWhereInput | LoginWhereInput[]
    IdLogin?: IntFilter<"Login"> | number
    IdUsuario?: IntFilter<"Login"> | number
    Correo?: StringFilter<"Login"> | string
    Contrasena?: StringFilter<"Login"> | string
    IdTipoLogin?: IntFilter<"Login"> | number
    FechaCreacion?: DateTimeNullableFilter<"Login"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Login"> | Date | string | null
    Estatus?: IntFilter<"Login"> | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type LoginOrderByWithRelationInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    Correo?: SortOrder
    Contrasena?: SortOrder
    IdTipoLogin?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type LoginWhereUniqueInput = Prisma.AtLeast<{
    IdLogin?: number
    IdUsuario?: number
    AND?: LoginWhereInput | LoginWhereInput[]
    OR?: LoginWhereInput[]
    NOT?: LoginWhereInput | LoginWhereInput[]
    Correo?: StringFilter<"Login"> | string
    Contrasena?: StringFilter<"Login"> | string
    IdTipoLogin?: IntFilter<"Login"> | number
    FechaCreacion?: DateTimeNullableFilter<"Login"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Login"> | Date | string | null
    Estatus?: IntFilter<"Login"> | number
    Usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "IdLogin" | "IdUsuario">

  export type LoginOrderByWithAggregationInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    Correo?: SortOrder
    Contrasena?: SortOrder
    IdTipoLogin?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: LoginCountOrderByAggregateInput
    _avg?: LoginAvgOrderByAggregateInput
    _max?: LoginMaxOrderByAggregateInput
    _min?: LoginMinOrderByAggregateInput
    _sum?: LoginSumOrderByAggregateInput
  }

  export type LoginScalarWhereWithAggregatesInput = {
    AND?: LoginScalarWhereWithAggregatesInput | LoginScalarWhereWithAggregatesInput[]
    OR?: LoginScalarWhereWithAggregatesInput[]
    NOT?: LoginScalarWhereWithAggregatesInput | LoginScalarWhereWithAggregatesInput[]
    IdLogin?: IntWithAggregatesFilter<"Login"> | number
    IdUsuario?: IntWithAggregatesFilter<"Login"> | number
    Correo?: StringWithAggregatesFilter<"Login"> | string
    Contrasena?: StringWithAggregatesFilter<"Login"> | string
    IdTipoLogin?: IntWithAggregatesFilter<"Login"> | number
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Login"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Login"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Login"> | number
  }

  export type ModuloWhereInput = {
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    IdModulo?: IntFilter<"Modulo"> | number
    Descripcion?: StringFilter<"Modulo"> | string
    Icono?: StringFilter<"Modulo"> | string
    Ruta?: StringFilter<"Modulo"> | string
    Padre?: StringFilter<"Modulo"> | string
    FechaCreacion?: DateTimeNullableFilter<"Modulo"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Modulo"> | Date | string | null
    Estatus?: IntFilter<"Modulo"> | number
  }

  export type ModuloOrderByWithRelationInput = {
    IdModulo?: SortOrder
    Descripcion?: SortOrder
    Icono?: SortOrder
    Ruta?: SortOrder
    Padre?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
  }

  export type ModuloWhereUniqueInput = Prisma.AtLeast<{
    IdModulo?: number
    AND?: ModuloWhereInput | ModuloWhereInput[]
    OR?: ModuloWhereInput[]
    NOT?: ModuloWhereInput | ModuloWhereInput[]
    Descripcion?: StringFilter<"Modulo"> | string
    Icono?: StringFilter<"Modulo"> | string
    Ruta?: StringFilter<"Modulo"> | string
    Padre?: StringFilter<"Modulo"> | string
    FechaCreacion?: DateTimeNullableFilter<"Modulo"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Modulo"> | Date | string | null
    Estatus?: IntFilter<"Modulo"> | number
  }, "IdModulo">

  export type ModuloOrderByWithAggregationInput = {
    IdModulo?: SortOrder
    Descripcion?: SortOrder
    Icono?: SortOrder
    Ruta?: SortOrder
    Padre?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: ModuloCountOrderByAggregateInput
    _avg?: ModuloAvgOrderByAggregateInput
    _max?: ModuloMaxOrderByAggregateInput
    _min?: ModuloMinOrderByAggregateInput
    _sum?: ModuloSumOrderByAggregateInput
  }

  export type ModuloScalarWhereWithAggregatesInput = {
    AND?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    OR?: ModuloScalarWhereWithAggregatesInput[]
    NOT?: ModuloScalarWhereWithAggregatesInput | ModuloScalarWhereWithAggregatesInput[]
    IdModulo?: IntWithAggregatesFilter<"Modulo"> | number
    Descripcion?: StringWithAggregatesFilter<"Modulo"> | string
    Icono?: StringWithAggregatesFilter<"Modulo"> | string
    Ruta?: StringWithAggregatesFilter<"Modulo"> | string
    Padre?: StringWithAggregatesFilter<"Modulo"> | string
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Modulo"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Modulo"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Modulo"> | number
  }

  export type PremioWhereInput = {
    AND?: PremioWhereInput | PremioWhereInput[]
    OR?: PremioWhereInput[]
    NOT?: PremioWhereInput | PremioWhereInput[]
    IdPremio?: IntFilter<"Premio"> | number
    IdSorteo?: IntFilter<"Premio"> | number
    Descripcion?: StringFilter<"Premio"> | string
    Lugar?: IntFilter<"Premio"> | number
    FechaCreacion?: DateTimeNullableFilter<"Premio"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Premio"> | Date | string | null
    Estatus?: IntFilter<"Premio"> | number
  }

  export type PremioOrderByWithRelationInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Descripcion?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
  }

  export type PremioWhereUniqueInput = Prisma.AtLeast<{
    IdPremio?: number
    AND?: PremioWhereInput | PremioWhereInput[]
    OR?: PremioWhereInput[]
    NOT?: PremioWhereInput | PremioWhereInput[]
    IdSorteo?: IntFilter<"Premio"> | number
    Descripcion?: StringFilter<"Premio"> | string
    Lugar?: IntFilter<"Premio"> | number
    FechaCreacion?: DateTimeNullableFilter<"Premio"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Premio"> | Date | string | null
    Estatus?: IntFilter<"Premio"> | number
  }, "IdPremio">

  export type PremioOrderByWithAggregationInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Descripcion?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: PremioCountOrderByAggregateInput
    _avg?: PremioAvgOrderByAggregateInput
    _max?: PremioMaxOrderByAggregateInput
    _min?: PremioMinOrderByAggregateInput
    _sum?: PremioSumOrderByAggregateInput
  }

  export type PremioScalarWhereWithAggregatesInput = {
    AND?: PremioScalarWhereWithAggregatesInput | PremioScalarWhereWithAggregatesInput[]
    OR?: PremioScalarWhereWithAggregatesInput[]
    NOT?: PremioScalarWhereWithAggregatesInput | PremioScalarWhereWithAggregatesInput[]
    IdPremio?: IntWithAggregatesFilter<"Premio"> | number
    IdSorteo?: IntWithAggregatesFilter<"Premio"> | number
    Descripcion?: StringWithAggregatesFilter<"Premio"> | string
    Lugar?: IntWithAggregatesFilter<"Premio"> | number
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Premio"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Premio"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Premio"> | number
  }

  export type SesionWhereInput = {
    AND?: SesionWhereInput | SesionWhereInput[]
    OR?: SesionWhereInput[]
    NOT?: SesionWhereInput | SesionWhereInput[]
    Correo?: StringFilter<"Sesion"> | string
    Token?: StringNullableFilter<"Sesion"> | string | null
  }

  export type SesionOrderByWithRelationInput = {
    Correo?: SortOrder
    Token?: SortOrderInput | SortOrder
  }

  export type SesionWhereUniqueInput = Prisma.AtLeast<{
    Correo?: string
    AND?: SesionWhereInput | SesionWhereInput[]
    OR?: SesionWhereInput[]
    NOT?: SesionWhereInput | SesionWhereInput[]
    Token?: StringNullableFilter<"Sesion"> | string | null
  }, "Correo">

  export type SesionOrderByWithAggregationInput = {
    Correo?: SortOrder
    Token?: SortOrderInput | SortOrder
    _count?: SesionCountOrderByAggregateInput
    _max?: SesionMaxOrderByAggregateInput
    _min?: SesionMinOrderByAggregateInput
  }

  export type SesionScalarWhereWithAggregatesInput = {
    AND?: SesionScalarWhereWithAggregatesInput | SesionScalarWhereWithAggregatesInput[]
    OR?: SesionScalarWhereWithAggregatesInput[]
    NOT?: SesionScalarWhereWithAggregatesInput | SesionScalarWhereWithAggregatesInput[]
    Correo?: StringWithAggregatesFilter<"Sesion"> | string
    Token?: StringNullableWithAggregatesFilter<"Sesion"> | string | null
  }

  export type SorteoWhereInput = {
    AND?: SorteoWhereInput | SorteoWhereInput[]
    OR?: SorteoWhereInput[]
    NOT?: SorteoWhereInput | SorteoWhereInput[]
    IdSorteo?: IntFilter<"Sorteo"> | number
    Nombre?: StringFilter<"Sorteo"> | string
    FechaSorteo?: DateTimeFilter<"Sorteo"> | Date | string
    FechaCreacion?: DateTimeNullableFilter<"Sorteo"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Sorteo"> | Date | string | null
    Estatus?: IntFilter<"Sorteo"> | number
  }

  export type SorteoOrderByWithRelationInput = {
    IdSorteo?: SortOrder
    Nombre?: SortOrder
    FechaSorteo?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
  }

  export type SorteoWhereUniqueInput = Prisma.AtLeast<{
    IdSorteo?: number
    AND?: SorteoWhereInput | SorteoWhereInput[]
    OR?: SorteoWhereInput[]
    NOT?: SorteoWhereInput | SorteoWhereInput[]
    Nombre?: StringFilter<"Sorteo"> | string
    FechaSorteo?: DateTimeFilter<"Sorteo"> | Date | string
    FechaCreacion?: DateTimeNullableFilter<"Sorteo"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Sorteo"> | Date | string | null
    Estatus?: IntFilter<"Sorteo"> | number
  }, "IdSorteo">

  export type SorteoOrderByWithAggregationInput = {
    IdSorteo?: SortOrder
    Nombre?: SortOrder
    FechaSorteo?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: SorteoCountOrderByAggregateInput
    _avg?: SorteoAvgOrderByAggregateInput
    _max?: SorteoMaxOrderByAggregateInput
    _min?: SorteoMinOrderByAggregateInput
    _sum?: SorteoSumOrderByAggregateInput
  }

  export type SorteoScalarWhereWithAggregatesInput = {
    AND?: SorteoScalarWhereWithAggregatesInput | SorteoScalarWhereWithAggregatesInput[]
    OR?: SorteoScalarWhereWithAggregatesInput[]
    NOT?: SorteoScalarWhereWithAggregatesInput | SorteoScalarWhereWithAggregatesInput[]
    IdSorteo?: IntWithAggregatesFilter<"Sorteo"> | number
    Nombre?: StringWithAggregatesFilter<"Sorteo"> | string
    FechaSorteo?: DateTimeWithAggregatesFilter<"Sorteo"> | Date | string
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Sorteo"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Sorteo"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Sorteo"> | number
  }

  export type TipoLoginWhereInput = {
    AND?: TipoLoginWhereInput | TipoLoginWhereInput[]
    OR?: TipoLoginWhereInput[]
    NOT?: TipoLoginWhereInput | TipoLoginWhereInput[]
    IdTipoLogin?: IntFilter<"TipoLogin"> | number
    Descripcion?: StringFilter<"TipoLogin"> | string
    FechaCreacion?: DateTimeNullableFilter<"TipoLogin"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"TipoLogin"> | Date | string | null
    Estatus?: IntFilter<"TipoLogin"> | number
  }

  export type TipoLoginOrderByWithRelationInput = {
    IdTipoLogin?: SortOrder
    Descripcion?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
  }

  export type TipoLoginWhereUniqueInput = Prisma.AtLeast<{
    IdTipoLogin?: number
    AND?: TipoLoginWhereInput | TipoLoginWhereInput[]
    OR?: TipoLoginWhereInput[]
    NOT?: TipoLoginWhereInput | TipoLoginWhereInput[]
    Descripcion?: StringFilter<"TipoLogin"> | string
    FechaCreacion?: DateTimeNullableFilter<"TipoLogin"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"TipoLogin"> | Date | string | null
    Estatus?: IntFilter<"TipoLogin"> | number
  }, "IdTipoLogin">

  export type TipoLoginOrderByWithAggregationInput = {
    IdTipoLogin?: SortOrder
    Descripcion?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: TipoLoginCountOrderByAggregateInput
    _avg?: TipoLoginAvgOrderByAggregateInput
    _max?: TipoLoginMaxOrderByAggregateInput
    _min?: TipoLoginMinOrderByAggregateInput
    _sum?: TipoLoginSumOrderByAggregateInput
  }

  export type TipoLoginScalarWhereWithAggregatesInput = {
    AND?: TipoLoginScalarWhereWithAggregatesInput | TipoLoginScalarWhereWithAggregatesInput[]
    OR?: TipoLoginScalarWhereWithAggregatesInput[]
    NOT?: TipoLoginScalarWhereWithAggregatesInput | TipoLoginScalarWhereWithAggregatesInput[]
    IdTipoLogin?: IntWithAggregatesFilter<"TipoLogin"> | number
    Descripcion?: StringWithAggregatesFilter<"TipoLogin"> | string
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"TipoLogin"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"TipoLogin"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"TipoLogin"> | number
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    IdUsuario?: IntFilter<"Usuario"> | number
    Nombre?: StringFilter<"Usuario"> | string
    ApPaterno?: StringFilter<"Usuario"> | string
    ApMaterno?: StringFilter<"Usuario"> | string
    Telefono?: StringFilter<"Usuario"> | string
    FechaCreacion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    Estatus?: IntFilter<"Usuario"> | number
    Direccion?: DireccionListRelationFilter
    Login?: XOR<LoginNullableRelationFilter, LoginWhereInput> | null
  }

  export type UsuarioOrderByWithRelationInput = {
    IdUsuario?: SortOrder
    Nombre?: SortOrder
    ApPaterno?: SortOrder
    ApMaterno?: SortOrder
    Telefono?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    Direccion?: DireccionOrderByRelationAggregateInput
    Login?: LoginOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    IdUsuario?: number
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    Nombre?: StringFilter<"Usuario"> | string
    ApPaterno?: StringFilter<"Usuario"> | string
    ApMaterno?: StringFilter<"Usuario"> | string
    Telefono?: StringFilter<"Usuario"> | string
    FechaCreacion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    Estatus?: IntFilter<"Usuario"> | number
    Direccion?: DireccionListRelationFilter
    Login?: XOR<LoginNullableRelationFilter, LoginWhereInput> | null
  }, "IdUsuario" | "IdUsuario">

  export type UsuarioOrderByWithAggregationInput = {
    IdUsuario?: SortOrder
    Nombre?: SortOrder
    ApPaterno?: SortOrder
    ApMaterno?: SortOrder
    Telefono?: SortOrder
    FechaCreacion?: SortOrderInput | SortOrder
    FechaActualizacion?: SortOrderInput | SortOrder
    Estatus?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    IdUsuario?: IntWithAggregatesFilter<"Usuario"> | number
    Nombre?: StringWithAggregatesFilter<"Usuario"> | string
    ApPaterno?: StringWithAggregatesFilter<"Usuario"> | string
    ApMaterno?: StringWithAggregatesFilter<"Usuario"> | string
    Telefono?: StringWithAggregatesFilter<"Usuario"> | string
    FechaCreacion?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    FechaActualizacion?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    Estatus?: IntWithAggregatesFilter<"Usuario"> | number
  }

  export type DireccionCreateInput = {
    Calle: string
    NumeroExt: string
    NumeroInt?: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Usuario: UsuarioCreateNestedOneWithoutDireccionInput
  }

  export type DireccionUncheckedCreateInput = {
    IdDireccion?: number
    IdUsuario: number
    Calle: string
    NumeroExt: string
    NumeroInt?: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type DireccionUpdateInput = {
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Usuario?: UsuarioUpdateOneRequiredWithoutDireccionNestedInput
  }

  export type DireccionUncheckedUpdateInput = {
    IdDireccion?: IntFieldUpdateOperationsInput | number
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionCreateManyInput = {
    IdDireccion?: number
    IdUsuario: number
    Calle: string
    NumeroExt: string
    NumeroInt?: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type DireccionUpdateManyMutationInput = {
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionUncheckedUpdateManyInput = {
    IdDireccion?: IntFieldUpdateOperationsInput | number
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type GanadorCreateInput = {
    IdSorteo: number
    Lugar: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type GanadorUncheckedCreateInput = {
    IdGanador?: number
    IdSorteo: number
    Lugar: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type GanadorUpdateInput = {
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type GanadorUncheckedUpdateInput = {
    IdGanador?: IntFieldUpdateOperationsInput | number
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type GanadorCreateManyInput = {
    IdGanador?: number
    IdSorteo: number
    Lugar: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type GanadorUpdateManyMutationInput = {
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type GanadorUncheckedUpdateManyInput = {
    IdGanador?: IntFieldUpdateOperationsInput | number
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type LoginCreateInput = {
    Correo: string
    Contrasena: string
    IdTipoLogin: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Usuario: UsuarioCreateNestedOneWithoutLoginInput
  }

  export type LoginUncheckedCreateInput = {
    IdLogin?: number
    IdUsuario: number
    Correo: string
    Contrasena: string
    IdTipoLogin: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type LoginUpdateInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Usuario?: UsuarioUpdateOneRequiredWithoutLoginNestedInput
  }

  export type LoginUncheckedUpdateInput = {
    IdLogin?: IntFieldUpdateOperationsInput | number
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Correo?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type LoginCreateManyInput = {
    IdLogin?: number
    IdUsuario: number
    Correo: string
    Contrasena: string
    IdTipoLogin: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type LoginUpdateManyMutationInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type LoginUncheckedUpdateManyInput = {
    IdLogin?: IntFieldUpdateOperationsInput | number
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Correo?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type ModuloCreateInput = {
    Descripcion: string
    Icono: string
    Ruta: string
    Padre: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type ModuloUncheckedCreateInput = {
    IdModulo?: number
    Descripcion: string
    Icono: string
    Ruta: string
    Padre: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type ModuloUpdateInput = {
    Descripcion?: StringFieldUpdateOperationsInput | string
    Icono?: StringFieldUpdateOperationsInput | string
    Ruta?: StringFieldUpdateOperationsInput | string
    Padre?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type ModuloUncheckedUpdateInput = {
    IdModulo?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    Icono?: StringFieldUpdateOperationsInput | string
    Ruta?: StringFieldUpdateOperationsInput | string
    Padre?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type ModuloCreateManyInput = {
    IdModulo?: number
    Descripcion: string
    Icono: string
    Ruta: string
    Padre: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type ModuloUpdateManyMutationInput = {
    Descripcion?: StringFieldUpdateOperationsInput | string
    Icono?: StringFieldUpdateOperationsInput | string
    Ruta?: StringFieldUpdateOperationsInput | string
    Padre?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type ModuloUncheckedUpdateManyInput = {
    IdModulo?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    Icono?: StringFieldUpdateOperationsInput | string
    Ruta?: StringFieldUpdateOperationsInput | string
    Padre?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type PremioCreateInput = {
    IdSorteo: number
    Descripcion: string
    Lugar: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type PremioUncheckedCreateInput = {
    IdPremio?: number
    IdSorteo: number
    Descripcion: string
    Lugar: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type PremioUpdateInput = {
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type PremioUncheckedUpdateInput = {
    IdPremio?: IntFieldUpdateOperationsInput | number
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type PremioCreateManyInput = {
    IdPremio?: number
    IdSorteo: number
    Descripcion: string
    Lugar: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type PremioUpdateManyMutationInput = {
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type PremioUncheckedUpdateManyInput = {
    IdPremio?: IntFieldUpdateOperationsInput | number
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    Lugar?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type SesionCreateInput = {
    Correo: string
    Token?: string | null
  }

  export type SesionUncheckedCreateInput = {
    Correo: string
    Token?: string | null
  }

  export type SesionUpdateInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SesionUncheckedUpdateInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SesionCreateManyInput = {
    Correo: string
    Token?: string | null
  }

  export type SesionUpdateManyMutationInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SesionUncheckedUpdateManyInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SorteoCreateInput = {
    Nombre: string
    FechaSorteo: Date | string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type SorteoUncheckedCreateInput = {
    IdSorteo?: number
    Nombre: string
    FechaSorteo: Date | string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type SorteoUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    FechaSorteo?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type SorteoUncheckedUpdateInput = {
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    FechaSorteo?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type SorteoCreateManyInput = {
    IdSorteo?: number
    Nombre: string
    FechaSorteo: Date | string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type SorteoUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    FechaSorteo?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type SorteoUncheckedUpdateManyInput = {
    IdSorteo?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    FechaSorteo?: DateTimeFieldUpdateOperationsInput | Date | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type TipoLoginCreateInput = {
    Descripcion: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type TipoLoginUncheckedCreateInput = {
    IdTipoLogin?: number
    Descripcion: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type TipoLoginUpdateInput = {
    Descripcion?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type TipoLoginUncheckedUpdateInput = {
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type TipoLoginCreateManyInput = {
    IdTipoLogin?: number
    Descripcion: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type TipoLoginUpdateManyMutationInput = {
    Descripcion?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type TipoLoginUncheckedUpdateManyInput = {
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    Descripcion?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateInput = {
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Direccion?: DireccionCreateNestedManyWithoutUsuarioInput
    Login?: LoginCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    IdUsuario?: number
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Direccion?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
    Login?: LoginUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Direccion?: DireccionUpdateManyWithoutUsuarioNestedInput
    Login?: LoginUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Direccion?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
    Login?: LoginUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    IdUsuario?: number
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type UsuarioUpdateManyMutationInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUncheckedUpdateManyInput = {
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DireccionCountOrderByAggregateInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Calle?: SortOrder
    NumeroExt?: SortOrder
    NumeroInt?: SortOrder
    Colonia?: SortOrder
    Municipio?: SortOrder
    Estado?: SortOrder
    CP?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type DireccionAvgOrderByAggregateInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Estatus?: SortOrder
  }

  export type DireccionMaxOrderByAggregateInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Calle?: SortOrder
    NumeroExt?: SortOrder
    NumeroInt?: SortOrder
    Colonia?: SortOrder
    Municipio?: SortOrder
    Estado?: SortOrder
    CP?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type DireccionMinOrderByAggregateInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Calle?: SortOrder
    NumeroExt?: SortOrder
    NumeroInt?: SortOrder
    Colonia?: SortOrder
    Municipio?: SortOrder
    Estado?: SortOrder
    CP?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type DireccionSumOrderByAggregateInput = {
    IdDireccion?: SortOrder
    IdUsuario?: SortOrder
    Estatus?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type GanadorCountOrderByAggregateInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type GanadorAvgOrderByAggregateInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    Estatus?: SortOrder
  }

  export type GanadorMaxOrderByAggregateInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type GanadorMinOrderByAggregateInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type GanadorSumOrderByAggregateInput = {
    IdGanador?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    Estatus?: SortOrder
  }

  export type LoginCountOrderByAggregateInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    Correo?: SortOrder
    Contrasena?: SortOrder
    IdTipoLogin?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type LoginAvgOrderByAggregateInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    IdTipoLogin?: SortOrder
    Estatus?: SortOrder
  }

  export type LoginMaxOrderByAggregateInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    Correo?: SortOrder
    Contrasena?: SortOrder
    IdTipoLogin?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type LoginMinOrderByAggregateInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    Correo?: SortOrder
    Contrasena?: SortOrder
    IdTipoLogin?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type LoginSumOrderByAggregateInput = {
    IdLogin?: SortOrder
    IdUsuario?: SortOrder
    IdTipoLogin?: SortOrder
    Estatus?: SortOrder
  }

  export type ModuloCountOrderByAggregateInput = {
    IdModulo?: SortOrder
    Descripcion?: SortOrder
    Icono?: SortOrder
    Ruta?: SortOrder
    Padre?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type ModuloAvgOrderByAggregateInput = {
    IdModulo?: SortOrder
    Estatus?: SortOrder
  }

  export type ModuloMaxOrderByAggregateInput = {
    IdModulo?: SortOrder
    Descripcion?: SortOrder
    Icono?: SortOrder
    Ruta?: SortOrder
    Padre?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type ModuloMinOrderByAggregateInput = {
    IdModulo?: SortOrder
    Descripcion?: SortOrder
    Icono?: SortOrder
    Ruta?: SortOrder
    Padre?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type ModuloSumOrderByAggregateInput = {
    IdModulo?: SortOrder
    Estatus?: SortOrder
  }

  export type PremioCountOrderByAggregateInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Descripcion?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type PremioAvgOrderByAggregateInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    Estatus?: SortOrder
  }

  export type PremioMaxOrderByAggregateInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Descripcion?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type PremioMinOrderByAggregateInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Descripcion?: SortOrder
    Lugar?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type PremioSumOrderByAggregateInput = {
    IdPremio?: SortOrder
    IdSorteo?: SortOrder
    Lugar?: SortOrder
    Estatus?: SortOrder
  }

  export type SesionCountOrderByAggregateInput = {
    Correo?: SortOrder
    Token?: SortOrder
  }

  export type SesionMaxOrderByAggregateInput = {
    Correo?: SortOrder
    Token?: SortOrder
  }

  export type SesionMinOrderByAggregateInput = {
    Correo?: SortOrder
    Token?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SorteoCountOrderByAggregateInput = {
    IdSorteo?: SortOrder
    Nombre?: SortOrder
    FechaSorteo?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type SorteoAvgOrderByAggregateInput = {
    IdSorteo?: SortOrder
    Estatus?: SortOrder
  }

  export type SorteoMaxOrderByAggregateInput = {
    IdSorteo?: SortOrder
    Nombre?: SortOrder
    FechaSorteo?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type SorteoMinOrderByAggregateInput = {
    IdSorteo?: SortOrder
    Nombre?: SortOrder
    FechaSorteo?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type SorteoSumOrderByAggregateInput = {
    IdSorteo?: SortOrder
    Estatus?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TipoLoginCountOrderByAggregateInput = {
    IdTipoLogin?: SortOrder
    Descripcion?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type TipoLoginAvgOrderByAggregateInput = {
    IdTipoLogin?: SortOrder
    Estatus?: SortOrder
  }

  export type TipoLoginMaxOrderByAggregateInput = {
    IdTipoLogin?: SortOrder
    Descripcion?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type TipoLoginMinOrderByAggregateInput = {
    IdTipoLogin?: SortOrder
    Descripcion?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type TipoLoginSumOrderByAggregateInput = {
    IdTipoLogin?: SortOrder
    Estatus?: SortOrder
  }

  export type DireccionListRelationFilter = {
    every?: DireccionWhereInput
    some?: DireccionWhereInput
    none?: DireccionWhereInput
  }

  export type LoginNullableRelationFilter = {
    is?: LoginWhereInput | null
    isNot?: LoginWhereInput | null
  }

  export type DireccionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    IdUsuario?: SortOrder
    Nombre?: SortOrder
    ApPaterno?: SortOrder
    ApMaterno?: SortOrder
    Telefono?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    IdUsuario?: SortOrder
    Estatus?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    IdUsuario?: SortOrder
    Nombre?: SortOrder
    ApPaterno?: SortOrder
    ApMaterno?: SortOrder
    Telefono?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    IdUsuario?: SortOrder
    Nombre?: SortOrder
    ApPaterno?: SortOrder
    ApMaterno?: SortOrder
    Telefono?: SortOrder
    FechaCreacion?: SortOrder
    FechaActualizacion?: SortOrder
    Estatus?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    IdUsuario?: SortOrder
    Estatus?: SortOrder
  }

  export type UsuarioCreateNestedOneWithoutDireccionInput = {
    create?: XOR<UsuarioCreateWithoutDireccionInput, UsuarioUncheckedCreateWithoutDireccionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDireccionInput
    connect?: UsuarioWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutDireccionNestedInput = {
    create?: XOR<UsuarioCreateWithoutDireccionInput, UsuarioUncheckedCreateWithoutDireccionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDireccionInput
    upsert?: UsuarioUpsertWithoutDireccionInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutDireccionInput, UsuarioUpdateWithoutDireccionInput>, UsuarioUncheckedUpdateWithoutDireccionInput>
  }

  export type UsuarioCreateNestedOneWithoutLoginInput = {
    create?: XOR<UsuarioCreateWithoutLoginInput, UsuarioUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLoginInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutLoginNestedInput = {
    create?: XOR<UsuarioCreateWithoutLoginInput, UsuarioUncheckedCreateWithoutLoginInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLoginInput
    upsert?: UsuarioUpsertWithoutLoginInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutLoginInput, UsuarioUpdateWithoutLoginInput>, UsuarioUncheckedUpdateWithoutLoginInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DireccionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput> | DireccionCreateWithoutUsuarioInput[] | DireccionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DireccionCreateOrConnectWithoutUsuarioInput | DireccionCreateOrConnectWithoutUsuarioInput[]
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    connect?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
  }

  export type LoginCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<LoginCreateWithoutUsuarioInput, LoginUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: LoginCreateOrConnectWithoutUsuarioInput
    connect?: LoginWhereUniqueInput
  }

  export type DireccionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput> | DireccionCreateWithoutUsuarioInput[] | DireccionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DireccionCreateOrConnectWithoutUsuarioInput | DireccionCreateOrConnectWithoutUsuarioInput[]
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    connect?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
  }

  export type LoginUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<LoginCreateWithoutUsuarioInput, LoginUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: LoginCreateOrConnectWithoutUsuarioInput
    connect?: LoginWhereUniqueInput
  }

  export type DireccionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput> | DireccionCreateWithoutUsuarioInput[] | DireccionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DireccionCreateOrConnectWithoutUsuarioInput | DireccionCreateOrConnectWithoutUsuarioInput[]
    upsert?: DireccionUpsertWithWhereUniqueWithoutUsuarioInput | DireccionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    set?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    disconnect?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    delete?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    connect?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    update?: DireccionUpdateWithWhereUniqueWithoutUsuarioInput | DireccionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: DireccionUpdateManyWithWhereWithoutUsuarioInput | DireccionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: DireccionScalarWhereInput | DireccionScalarWhereInput[]
  }

  export type LoginUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<LoginCreateWithoutUsuarioInput, LoginUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: LoginCreateOrConnectWithoutUsuarioInput
    upsert?: LoginUpsertWithoutUsuarioInput
    disconnect?: LoginWhereInput | boolean
    delete?: LoginWhereInput | boolean
    connect?: LoginWhereUniqueInput
    update?: XOR<XOR<LoginUpdateToOneWithWhereWithoutUsuarioInput, LoginUpdateWithoutUsuarioInput>, LoginUncheckedUpdateWithoutUsuarioInput>
  }

  export type DireccionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput> | DireccionCreateWithoutUsuarioInput[] | DireccionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DireccionCreateOrConnectWithoutUsuarioInput | DireccionCreateOrConnectWithoutUsuarioInput[]
    upsert?: DireccionUpsertWithWhereUniqueWithoutUsuarioInput | DireccionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: DireccionCreateManyUsuarioInputEnvelope
    set?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    disconnect?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    delete?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    connect?: DireccionWhereUniqueInput | DireccionWhereUniqueInput[]
    update?: DireccionUpdateWithWhereUniqueWithoutUsuarioInput | DireccionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: DireccionUpdateManyWithWhereWithoutUsuarioInput | DireccionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: DireccionScalarWhereInput | DireccionScalarWhereInput[]
  }

  export type LoginUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<LoginCreateWithoutUsuarioInput, LoginUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: LoginCreateOrConnectWithoutUsuarioInput
    upsert?: LoginUpsertWithoutUsuarioInput
    disconnect?: LoginWhereInput | boolean
    delete?: LoginWhereInput | boolean
    connect?: LoginWhereUniqueInput
    update?: XOR<XOR<LoginUpdateToOneWithWhereWithoutUsuarioInput, LoginUpdateWithoutUsuarioInput>, LoginUncheckedUpdateWithoutUsuarioInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsuarioCreateWithoutDireccionInput = {
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Login?: LoginCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDireccionInput = {
    IdUsuario?: number
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Login?: LoginUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDireccionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDireccionInput, UsuarioUncheckedCreateWithoutDireccionInput>
  }

  export type UsuarioUpsertWithoutDireccionInput = {
    update: XOR<UsuarioUpdateWithoutDireccionInput, UsuarioUncheckedUpdateWithoutDireccionInput>
    create: XOR<UsuarioCreateWithoutDireccionInput, UsuarioUncheckedCreateWithoutDireccionInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutDireccionInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutDireccionInput, UsuarioUncheckedUpdateWithoutDireccionInput>
  }

  export type UsuarioUpdateWithoutDireccionInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Login?: LoginUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDireccionInput = {
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Login?: LoginUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutLoginInput = {
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Direccion?: DireccionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutLoginInput = {
    IdUsuario?: number
    Nombre: string
    ApPaterno: string
    ApMaterno: string
    Telefono: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
    Direccion?: DireccionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutLoginInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutLoginInput, UsuarioUncheckedCreateWithoutLoginInput>
  }

  export type UsuarioUpsertWithoutLoginInput = {
    update: XOR<UsuarioUpdateWithoutLoginInput, UsuarioUncheckedUpdateWithoutLoginInput>
    create: XOR<UsuarioCreateWithoutLoginInput, UsuarioUncheckedCreateWithoutLoginInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutLoginInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutLoginInput, UsuarioUncheckedUpdateWithoutLoginInput>
  }

  export type UsuarioUpdateWithoutLoginInput = {
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Direccion?: DireccionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutLoginInput = {
    IdUsuario?: IntFieldUpdateOperationsInput | number
    Nombre?: StringFieldUpdateOperationsInput | string
    ApPaterno?: StringFieldUpdateOperationsInput | string
    ApMaterno?: StringFieldUpdateOperationsInput | string
    Telefono?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
    Direccion?: DireccionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type DireccionCreateWithoutUsuarioInput = {
    Calle: string
    NumeroExt: string
    NumeroInt?: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type DireccionUncheckedCreateWithoutUsuarioInput = {
    IdDireccion?: number
    Calle: string
    NumeroExt: string
    NumeroInt?: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type DireccionCreateOrConnectWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    create: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionCreateManyUsuarioInputEnvelope = {
    data: DireccionCreateManyUsuarioInput | DireccionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type LoginCreateWithoutUsuarioInput = {
    Correo: string
    Contrasena: string
    IdTipoLogin: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type LoginUncheckedCreateWithoutUsuarioInput = {
    IdLogin?: number
    Correo: string
    Contrasena: string
    IdTipoLogin: number
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type LoginCreateOrConnectWithoutUsuarioInput = {
    where: LoginWhereUniqueInput
    create: XOR<LoginCreateWithoutUsuarioInput, LoginUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    update: XOR<DireccionUpdateWithoutUsuarioInput, DireccionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<DireccionCreateWithoutUsuarioInput, DireccionUncheckedCreateWithoutUsuarioInput>
  }

  export type DireccionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: DireccionWhereUniqueInput
    data: XOR<DireccionUpdateWithoutUsuarioInput, DireccionUncheckedUpdateWithoutUsuarioInput>
  }

  export type DireccionUpdateManyWithWhereWithoutUsuarioInput = {
    where: DireccionScalarWhereInput
    data: XOR<DireccionUpdateManyMutationInput, DireccionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type DireccionScalarWhereInput = {
    AND?: DireccionScalarWhereInput | DireccionScalarWhereInput[]
    OR?: DireccionScalarWhereInput[]
    NOT?: DireccionScalarWhereInput | DireccionScalarWhereInput[]
    IdDireccion?: IntFilter<"Direccion"> | number
    IdUsuario?: IntFilter<"Direccion"> | number
    Calle?: StringFilter<"Direccion"> | string
    NumeroExt?: StringFilter<"Direccion"> | string
    NumeroInt?: StringNullableFilter<"Direccion"> | string | null
    Colonia?: StringFilter<"Direccion"> | string
    Municipio?: StringFilter<"Direccion"> | string
    Estado?: StringFilter<"Direccion"> | string
    CP?: StringFilter<"Direccion"> | string
    FechaCreacion?: DateTimeNullableFilter<"Direccion"> | Date | string | null
    FechaActualizacion?: DateTimeNullableFilter<"Direccion"> | Date | string | null
    Estatus?: IntFilter<"Direccion"> | number
  }

  export type LoginUpsertWithoutUsuarioInput = {
    update: XOR<LoginUpdateWithoutUsuarioInput, LoginUncheckedUpdateWithoutUsuarioInput>
    create: XOR<LoginCreateWithoutUsuarioInput, LoginUncheckedCreateWithoutUsuarioInput>
    where?: LoginWhereInput
  }

  export type LoginUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: LoginWhereInput
    data: XOR<LoginUpdateWithoutUsuarioInput, LoginUncheckedUpdateWithoutUsuarioInput>
  }

  export type LoginUpdateWithoutUsuarioInput = {
    Correo?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type LoginUncheckedUpdateWithoutUsuarioInput = {
    IdLogin?: IntFieldUpdateOperationsInput | number
    Correo?: StringFieldUpdateOperationsInput | string
    Contrasena?: StringFieldUpdateOperationsInput | string
    IdTipoLogin?: IntFieldUpdateOperationsInput | number
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionCreateManyUsuarioInput = {
    IdDireccion?: number
    Calle: string
    NumeroExt: string
    NumeroInt?: string | null
    Colonia: string
    Municipio: string
    Estado: string
    CP: string
    FechaCreacion?: Date | string | null
    FechaActualizacion?: Date | string | null
    Estatus: number
  }

  export type DireccionUpdateWithoutUsuarioInput = {
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionUncheckedUpdateWithoutUsuarioInput = {
    IdDireccion?: IntFieldUpdateOperationsInput | number
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }

  export type DireccionUncheckedUpdateManyWithoutUsuarioInput = {
    IdDireccion?: IntFieldUpdateOperationsInput | number
    Calle?: StringFieldUpdateOperationsInput | string
    NumeroExt?: StringFieldUpdateOperationsInput | string
    NumeroInt?: NullableStringFieldUpdateOperationsInput | string | null
    Colonia?: StringFieldUpdateOperationsInput | string
    Municipio?: StringFieldUpdateOperationsInput | string
    Estado?: StringFieldUpdateOperationsInput | string
    CP?: StringFieldUpdateOperationsInput | string
    FechaCreacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    FechaActualizacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Estatus?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DireccionDefaultArgs instead
     */
    export type DireccionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DireccionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GanadorDefaultArgs instead
     */
    export type GanadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GanadorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoginDefaultArgs instead
     */
    export type LoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuloDefaultArgs instead
     */
    export type ModuloArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuloDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PremioDefaultArgs instead
     */
    export type PremioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PremioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SesionDefaultArgs instead
     */
    export type SesionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SesionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SorteoDefaultArgs instead
     */
    export type SorteoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SorteoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoLoginDefaultArgs instead
     */
    export type TipoLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoLoginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}